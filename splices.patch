diff --git a/compiler/basicTypes/DataCon.hs b/compiler/basicTypes/DataCon.hs
index 6f0cf411b2..de39c26142 100644
--- a/compiler/basicTypes/DataCon.hs
+++ b/compiler/basicTypes/DataCon.hs
@@ -811,6 +811,7 @@ instance Binary SrcUnpackedness where
            1 -> return SrcUnpack
            _ -> return NoSrcUnpack
 
+
 -- | Compare strictness annotations
 eqHsBang :: HsImplBang -> HsImplBang -> Bool
 eqHsBang HsLazy               HsLazy              = True
diff --git a/compiler/basicTypes/IdInfo.hs b/compiler/basicTypes/IdInfo.hs
index f6febaf4dc..aed09b6a42 100644
--- a/compiler/basicTypes/IdInfo.hs
+++ b/compiler/basicTypes/IdInfo.hs
@@ -18,7 +18,7 @@ module IdInfo (
         RecSelParent(..),
 
         -- * The IdInfo type
-        IdInfo,         -- Abstract
+        IdInfo,
         vanillaIdInfo, noCafIdInfo,
 
         -- ** The OneShotInfo type
diff --git a/compiler/basicTypes/IdInfo.hs-boot b/compiler/basicTypes/IdInfo.hs-boot
index cacfe6af2e..229ff9abb0 100644
--- a/compiler/basicTypes/IdInfo.hs-boot
+++ b/compiler/basicTypes/IdInfo.hs-boot
@@ -1,6 +1,7 @@
 module IdInfo where
 import GhcPrelude
 import Outputable
+
 data IdInfo
 data IdDetails
 
@@ -8,4 +9,3 @@ vanillaIdInfo :: IdInfo
 coVarDetails :: IdDetails
 isCoVarDetails :: IdDetails -> Bool
 pprIdDetails :: IdDetails -> SDoc
-
diff --git a/compiler/basicTypes/OccName.hs b/compiler/basicTypes/OccName.hs
index 1af53fb3dc..fa54967e8a 100644
--- a/compiler/basicTypes/OccName.hs
+++ b/compiler/basicTypes/OccName.hs
@@ -394,6 +394,10 @@ instance Uniquable OccName where
 newtype OccEnv a = A (UniqFM a)
   deriving Data
 
+instance Binary a => Binary (OccEnv a) where
+  put_ bh (A a) = put_ bh a
+  get bh = A <$> get bh
+
 emptyOccEnv :: OccEnv a
 unitOccEnv  :: OccName -> a -> OccEnv a
 extendOccEnv :: OccEnv a -> OccName -> a -> OccEnv a
diff --git a/compiler/basicTypes/PatSyn.hs b/compiler/basicTypes/PatSyn.hs
index 2e838d6b82..76b93e4224 100644
--- a/compiler/basicTypes/PatSyn.hs
+++ b/compiler/basicTypes/PatSyn.hs
@@ -32,6 +32,7 @@ import Outputable
 import Unique
 import Util
 import BasicTypes
+import Binary
 import Var
 import FieldLabel
 
@@ -328,6 +329,10 @@ instance Data.Data PatSyn where
     gunfold _ _  = error "gunfold"
     dataTypeOf _ = mkNoRepType "PatSyn"
 
+instance Binary PatSyn where
+  put = error "Binary PatSyn: not implemented yet"
+  get = error "Binary PatSyn: not implemented yet"
+
 {-
 ************************************************************************
 *                                                                      *
diff --git a/compiler/basicTypes/RdrName.hs b/compiler/basicTypes/RdrName.hs
index bc90dafa98..b9c16d67ef 100644
--- a/compiler/basicTypes/RdrName.hs
+++ b/compiler/basicTypes/RdrName.hs
@@ -73,6 +73,7 @@ import GhcPrelude
 import Module
 import Name
 import Avail
+import Binary
 import NameSet
 import Maybes
 import SrcLoc
@@ -468,6 +469,10 @@ data GlobalRdrElt
          -- INVARIANT: either gre_lcl = True or gre_imp is non-empty
          -- See Note [GlobalRdrElt provenance]
 
+instance Binary GlobalRdrElt where
+  put_ bh (GRE a b c d) = put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+  get bh = GRE <$> get bh <*> get bh <*> get bh <*> get bh
+
 -- | The children of a Name are the things that are abbreviated by the ".."
 --   notation in export lists.  See Note [Parents]
 data Parent = NoParent
@@ -476,6 +481,18 @@ data Parent = NoParent
               -- ^ See Note [Parents for record fields]
             deriving (Eq, Data)
 
+instance Binary Parent where
+  put_ bh p = case p of
+    NoParent      -> putByte bh 0
+    ParentIs p    -> putByte bh 1 >> put_ bh p
+    FldParent a b -> putByte bh 2 >> put_ bh a >> put_ bh b
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure NoParent
+      1 -> ParentIs <$> get bh
+      _ -> FldParent <$> get bh <*> get bh
+
 instance Outputable Parent where
    ppr NoParent        = empty
    ppr (ParentIs n)    = text "parent:" <> ppr n
@@ -1136,6 +1153,10 @@ data ImportSpec = ImpSpec { is_decl :: ImpDeclSpec,
                             is_item :: ImpItemSpec }
                 deriving( Eq, Ord, Data )
 
+instance Binary ImportSpec where
+  put_ bh (ImpSpec a b) = put_ bh a >> put_ bh b
+  get bh = ImpSpec <$> get bh <*> get bh
+
 -- | Import Declaration Specification
 --
 -- Describes a particular import declaration and is
@@ -1153,6 +1174,11 @@ data ImpDeclSpec
         is_dloc     :: SrcSpan     -- ^ The location of the entire import declaration
     } deriving Data
 
+instance Binary ImpDeclSpec where
+  put_ bh (ImpDeclSpec a b c d) =
+    put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+  get bh = ImpDeclSpec <$> get bh <*> get bh <*> get bh <*> get bh
+
 -- | Import Item Specification
 --
 -- Describes import info a particular Name
@@ -1174,6 +1200,16 @@ data ImpItemSpec
         -- only @T@ is named explicitly.
   deriving Data
 
+instance Binary ImpItemSpec where
+  put_ bh s = case s of
+    ImpAll      -> putByte bh 0
+    ImpSome a b -> putByte bh 1 >> put_ bh a >> put_ bh b
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure ImpAll
+      _ -> ImpSome <$> get bh <*> get bh
+
 instance Eq ImpDeclSpec where
   p1 == p2 = case p1 `compare` p2 of EQ -> True; _ -> False
 
diff --git a/compiler/ghc.cabal.in b/compiler/ghc.cabal.in
index a6e6149f9f..b3d23101e0 100644
--- a/compiler/ghc.cabal.in
+++ b/compiler/ghc.cabal.in
@@ -210,6 +210,7 @@ Library
         NameSet
         OccName
         RdrName
+        SeName
         NameCache
         SrcLoc
         UniqSupply
@@ -317,6 +318,9 @@ Library
         HsDecls
         HsDoc
         HsExpr
+        HsExprBin
+        HsExprBin_Conversions
+        HsExprBin_Instances
         HsImpExp
         HsLit
         PlaceHolder
diff --git a/compiler/hsSyn/HsBinds.hs b/compiler/hsSyn/HsBinds.hs
index e4a6906996..0997a0aaf4 100644
--- a/compiler/hsSyn/HsBinds.hs
+++ b/compiler/hsSyn/HsBinds.hs
@@ -25,6 +25,7 @@ import {-# SOURCE #-} HsExpr ( pprExpr, LHsExpr,
                                GRHSs, pprPatBind )
 import {-# SOURCE #-} HsPat  ( LPat )
 
+import Binary
 import HsExtension
 import HsTypes
 import PprCore ()
@@ -94,6 +95,23 @@ data HsLocalBindsLR idL idR
   | XHsLocalBindsLR
         (XXHsLocalBindsLR idL idR)
 
+instance ( Binary (XHsValBinds l r), Binary (HsValBindsLR l r)
+         , Binary (XHsIPBinds l r), Binary (HsIPBinds r)
+         , Binary (XEmptyLocalBinds l r), Binary (XXHsLocalBindsLR l r)
+         ) => Binary (HsLocalBindsLR l r) where
+  put_ bh b = case b of
+    HsValBinds a b    -> putByte bh 0 >> put_ bh a >> put_ bh b
+    HsIPBinds a b     -> putByte bh 1 >> put_ bh a >> put_ bh b
+    EmptyLocalBinds a -> putByte bh 2 >> put_ bh a
+    XHsLocalBindsLR a -> putByte bh 3 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsValBinds      <$> get bh <*> get bh
+      1 -> HsIPBinds       <$> get bh <*> get bh
+      2 -> EmptyLocalBinds <$> get bh
+      _ -> XHsLocalBindsLR <$> get bh
+
 type instance XHsValBinds      (GhcPass pL) (GhcPass pR) = NoExt
 type instance XHsIPBinds       (GhcPass pL) (GhcPass pR) = NoExt
 type instance XEmptyLocalBinds (GhcPass pL) (GhcPass pR) = NoExt
@@ -126,6 +144,19 @@ data HsValBindsLR idL idR
   | XValBindsLR
       (XXValBindsLR idL idR)
 
+instance ( Binary (Sig r), Binary (XValBinds l r), Binary (LHsBindsLR l r)
+         ) => Binary (HsValBindsLR l r) where
+  put_ bh b = case b of
+    ValBinds a b c -> putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    _ -> panic "Binary HsValBindsLR.put: XValBindsLR constructor not supported"
+    -- XValBindsLR a  -> putByte bh 1 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> ValBinds <$> get bh <*> get bh <*> get bh
+      _ -> panic "Binary HsValBindsLR.get: unknown tag"
+      -- _ -> XValBindsLR <$> get bh
+
 -- ---------------------------------------------------------------------
 -- Deal with ValBindsOut
 
@@ -322,9 +353,11 @@ data NPatBindTc = NPatBindTc {
 type instance XFunBind    (GhcPass pL) GhcPs = NoExt
 type instance XFunBind    (GhcPass pL) GhcRn = NameSet -- Free variables
 type instance XFunBind    (GhcPass pL) GhcTc = NameSet -- Free variables
+type instance XFunBind    (GhcPass pL) GhcSe = NoExt
 
 type instance XPatBind    GhcPs (GhcPass pR) = NoExt
 type instance XPatBind    GhcRn (GhcPass pR) = NameSet -- Free variables
+type instance XPatBind    GhcSe (GhcPass pR) = NoExt
 type instance XPatBind    GhcTc (GhcPass pR) = NPatBindTc
 
 type instance XVarBind    (GhcPass pL) (GhcPass pR) = NoExt
@@ -382,6 +415,7 @@ data PatSynBind idL idR
 type instance XPSB         (GhcPass idL) GhcPs = NoExt
 type instance XPSB         (GhcPass idL) GhcRn = NameSet
 type instance XPSB         (GhcPass idL) GhcTc = NameSet
+type instance XPSB         (GhcPass idL) GhcSe = NoExt
 
 type instance XXPatSynBind (GhcPass idL) (GhcPass idR) = NoExt
 
@@ -828,6 +862,7 @@ type instance XIPBinds       GhcPs = NoExt
 type instance XIPBinds       GhcRn = NoExt
 type instance XIPBinds       GhcTc = TcEvBinds -- binds uses of the
                                                -- implicit parameters
+type instance XIPBinds       GhcSe = NoExt
 
 
 type instance XXHsIPBinds    (GhcPass p) = NoExt
@@ -868,12 +903,13 @@ type instance XIPBind     (GhcPass p) = NoExt
 type instance XXIPBind    (GhcPass p) = NoExt
 
 instance (p ~ GhcPass pass, OutputableBndrId p)
-       => Outputable (HsIPBinds p) where
+      => Outputable (HsIPBinds p) where
   ppr (IPBinds ds bs) = pprDeeperList vcat (map ppr bs)
                         $$ whenPprDebug (ppr ds)
   ppr (XHsIPBinds x) = ppr x
 
-instance (p ~ GhcPass pass, OutputableBndrId p) => Outputable (IPBind p) where
+instance (p ~ GhcPass pass, OutputableBndrId p)
+      => Outputable (IPBind p) where
   ppr (IPBind _ lr rhs) = name <+> equals <+> pprExpr (unLoc rhs)
     where name = case lr of
                    Left (L _ ip) -> pprBndr LetBind ip
@@ -948,7 +984,7 @@ data Sig pass
         -- the desired Id itself, replete with its name, type
         -- and IdDetails.  Otherwise it's just like a type
         -- signature: there should be an accompanying binding
-  | IdSig (XIdSig pass) Id
+  | IdSig (XIdSig pass) (IdSigId pass)
 
         -- | An ordinary fixity declaration
         --
@@ -1169,10 +1205,13 @@ signatures. Since some of the signatures contain a list of names, testing for
 equality is not enough -- we have to check if they overlap.
 -}
 
-instance (p ~ GhcPass pass, OutputableBndrId p) => Outputable (Sig p) where
+instance (p ~ GhcPass pass, OutputableBndrId p)
+      => Outputable (Sig p) where
     ppr sig = ppr_sig sig
 
-ppr_sig :: (OutputableBndrId (GhcPass p)) => Sig (GhcPass p) -> SDoc
+ppr_sig
+  :: ( OutputableBndrId (GhcPass p) )
+  => Sig (GhcPass p) -> SDoc
 ppr_sig (TypeSig _ vars ty)  = pprVarSig (map unLoc vars) (ppr ty)
 ppr_sig (ClassOpSig _ is_deflt vars ty)
   | is_deflt                 = text "default" <+> pprVarSig (map unLoc vars) (ppr ty)
diff --git a/compiler/hsSyn/HsDecls.hs b/compiler/hsSyn/HsDecls.hs
index d389f61e86..fed202f6c1 100644
--- a/compiler/hsSyn/HsDecls.hs
+++ b/compiler/hsSyn/HsDecls.hs
@@ -265,7 +265,8 @@ appendGroups
         hs_docs   = docs1  ++ docs2 }
 appendGroups _ _ = panic "appendGroups"
 
-instance (p ~ GhcPass pass, OutputableBndrId p) => Outputable (HsDecl p) where
+instance (p ~ GhcPass pass, OutputableBndrId p)
+      => Outputable (HsDecl p) where
     ppr (TyClD _ dcl)             = ppr dcl
     ppr (ValD _ binds)            = ppr binds
     ppr (DefD _ def)              = ppr def
@@ -281,7 +282,8 @@ instance (p ~ GhcPass pass, OutputableBndrId p) => Outputable (HsDecl p) where
     ppr (RoleAnnotD _ ra)         = ppr ra
     ppr (XHsDecl x)               = ppr x
 
-instance (p ~ GhcPass pass, OutputableBndrId p) => Outputable (HsGroup p) where
+instance (p ~ GhcPass pass, OutputableBndrId p)
+      => Outputable (HsGroup p) where
     ppr (HsGroup { hs_valds  = val_decls,
                    hs_tyclds = tycl_decls,
                    hs_derivds = deriv_decls,
@@ -560,14 +562,17 @@ type instance XFamDecl      (GhcPass _) = NoExt
 type instance XSynDecl      GhcPs = NoExt
 type instance XSynDecl      GhcRn = NameSet -- FVs
 type instance XSynDecl      GhcTc = NameSet -- FVs
+type instance XSynDecl      GhcSe = NoExt
 
 type instance XDataDecl     GhcPs = NoExt
 type instance XDataDecl     GhcRn = DataDeclRn
 type instance XDataDecl     GhcTc = DataDeclRn
+type instance XDataDecl     GhcSe = NoExt
 
 type instance XClassDecl    GhcPs = NoExt
 type instance XClassDecl    GhcRn = NameSet -- FVs
 type instance XClassDecl    GhcTc = NameSet -- FVs
+type instance XClassDecl    GhcSe = NoExt
 
 type instance XXTyClDecl    (GhcPass _) = NoExt
 
@@ -677,7 +682,8 @@ hsDeclHasCusk (XTyClDecl _) = panic "hsDeclHasCusk"
 -- Pretty-printing TyClDecl
 -- ~~~~~~~~~~~~~~~~~~~~~~~~
 
-instance (p ~ GhcPass pass, OutputableBndrId p) => Outputable (TyClDecl p) where
+instance (p ~ GhcPass pass, OutputableBndrId p)
+      => Outputable (TyClDecl p) where
 
     ppr (FamDecl { tcdFam = decl }) = ppr decl
     ppr (SynDecl { tcdLName = ltycon, tcdTyVars = tyvars, tcdFixity = fixity
@@ -756,7 +762,6 @@ pprTyClDeclFlavour (DataDecl { tcdDataDefn = XHsDataDefn x })
   = ppr x
 pprTyClDeclFlavour (XTyClDecl x) = ppr x
 
-
 {- Note [Complete user-supplied kind signatures]
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 We kind-check declarations differently if they have a complete, user-supplied
@@ -1352,16 +1357,19 @@ instance Outputable NewOrData where
   ppr NewType  = text "newtype"
   ppr DataType = text "data"
 
-pp_condecls :: (OutputableBndrId (GhcPass p)) => [LConDecl (GhcPass p)] -> SDoc
+pp_condecls :: (OutputableBndrId (GhcPass p))
+            => [LConDecl (GhcPass p)] -> SDoc
 pp_condecls cs@(L _ ConDeclGADT{} : _) -- In GADT syntax
   = hang (text "where") 2 (vcat (map ppr cs))
 pp_condecls cs                    -- In H98 syntax
   = equals <+> sep (punctuate (text " |") (map ppr cs))
 
-instance (p ~ GhcPass pass, OutputableBndrId p) => Outputable (ConDecl p) where
+instance (p ~ GhcPass pass, OutputableBndrId p)
+      => Outputable (ConDecl p) where
     ppr = pprConDecl
 
-pprConDecl :: (OutputableBndrId (GhcPass p)) => ConDecl (GhcPass p) -> SDoc
+pprConDecl :: (OutputableBndrId (GhcPass p))
+           => ConDecl (GhcPass p) -> SDoc
 pprConDecl (ConDeclH98 { con_name = L _ con
                        , con_ex_tvs = ex_tvs
                        , con_mb_cxt = mcxt
@@ -1737,7 +1745,8 @@ ppOverlapPragma mb =
     maybe_stext (SourceText src) _   = text src <+> text "#-}"
 
 
-instance (p ~ GhcPass pass, OutputableBndrId p) => Outputable (InstDecl p) where
+instance (p ~ GhcPass pass, OutputableBndrId p)
+      => Outputable (InstDecl p) where
     ppr (ClsInstD     { cid_inst  = decl }) = ppr decl
     ppr (TyFamInstD   { tfid_inst = decl }) = ppr decl
     ppr (DataFamInstD { dfid_inst = decl }) = ppr decl
@@ -1891,10 +1900,12 @@ data ForeignDecl pass
 type instance XForeignImport   GhcPs = NoExt
 type instance XForeignImport   GhcRn = NoExt
 type instance XForeignImport   GhcTc = Coercion
+type instance XForeignImport   GhcSe = NoExt
 
 type instance XForeignExport   GhcPs = NoExt
 type instance XForeignExport   GhcRn = NoExt
 type instance XForeignExport   GhcTc = Coercion
+type instance XForeignExport   GhcSe = NoExt
 
 type instance XXForeignDecl    (GhcPass _) = NoExt
 
diff --git a/compiler/hsSyn/HsDoc.hs b/compiler/hsSyn/HsDoc.hs
index cbe1d94bec..d7ceed229d 100644
--- a/compiler/hsSyn/HsDoc.hs
+++ b/compiler/hsSyn/HsDoc.hs
@@ -14,6 +14,7 @@ module HsDoc
 
 import GhcPrelude
 
+import Binary
 import Encoding
 import FastFunctions
 import Outputable
@@ -30,6 +31,10 @@ import Foreign
 newtype HsDocString = HsDocString ByteString
   deriving (Eq, Show, Data)
 
+instance Binary HsDocString where
+  put_ bh (HsDocString s) = put_ bh s
+  get bh = HsDocString <$> get bh
+
 -- | Located Haskell Documentation String
 type LHsDocString = Located HsDocString
 
diff --git a/compiler/hsSyn/HsExpr.hs b/compiler/hsSyn/HsExpr.hs
index 96d86c871b..18e99f86f2 100644
--- a/compiler/hsSyn/HsExpr.hs
+++ b/compiler/hsSyn/HsExpr.hs
@@ -443,7 +443,7 @@ data HsExpr p
 
   -- For details on above see note [Api annotations] in ApiAnnotation
   | HsDo        (XDo p)                  -- Type of the whole expression
-                (HsStmtContext Name)     -- The parameterisation is unimportant
+                (HsStmtContext (XDoName p))  -- The parameterisation is unimportant
                                          -- because in this context we never use
                                          -- the PatGuard or ParStmt variant
                 (Located [ExprLStmt p]) -- "do":one or more stmts
@@ -681,7 +681,6 @@ data HsExpr p
 
   | XExpr       (XXExpr p) -- Note [Trees that Grow] extension constructor
 
-
 -- | Extra data fields for a 'RecordCon', added by the type checker
 data RecordConTc = RecordConTc
       { rcon_con_like :: ConLike      -- The data constructor or pattern synonym
@@ -719,10 +718,12 @@ type instance XApp           (GhcPass _) = NoExt
 type instance XAppTypeE      GhcPs = LHsWcType GhcPs
 type instance XAppTypeE      GhcRn = LHsWcType GhcRn
 type instance XAppTypeE      GhcTc = LHsWcType GhcRn
+type instance XAppTypeE      GhcSe = LHsWcType GhcSe
 
 type instance XOpApp         GhcPs = NoExt
 type instance XOpApp         GhcRn = Fixity
 type instance XOpApp         GhcTc = Fixity
+type instance XOpApp         GhcSe = NoExt
 
 type instance XNegApp        (GhcPass _) = NoExt
 type instance XPar           (GhcPass _) = NoExt
@@ -733,6 +734,7 @@ type instance XExplicitTuple (GhcPass _) = NoExt
 type instance XExplicitSum   GhcPs = NoExt
 type instance XExplicitSum   GhcRn = NoExt
 type instance XExplicitSum   GhcTc = [Type]
+type instance XExplicitSum   GhcSe = NoExt
 
 type instance XCase          (GhcPass _) = NoExt
 type instance XIf            (GhcPass _) = NoExt
@@ -740,32 +742,44 @@ type instance XIf            (GhcPass _) = NoExt
 type instance XMultiIf       GhcPs = NoExt
 type instance XMultiIf       GhcRn = NoExt
 type instance XMultiIf       GhcTc = Type
+type instance XMultiIf       GhcSe = NoExt
 
 type instance XLet           (GhcPass _) = NoExt
 
 type instance XDo            GhcPs = NoExt
 type instance XDo            GhcRn = NoExt
 type instance XDo            GhcTc = Type
+type instance XDo            GhcSe = NoExt
+
+type instance XDoName        GhcPs = Name
+type instance XDoName        GhcRn = Name
+type instance XDoName        GhcTc = Name
+type instance XDoName        GhcSe = IdP GhcSe
 
 type instance XExplicitList  GhcPs = NoExt
 type instance XExplicitList  GhcRn = NoExt
 type instance XExplicitList  GhcTc = Type
+type instance XExplicitList  GhcSe = NoExt
 
 type instance XRecordCon     GhcPs = NoExt
 type instance XRecordCon     GhcRn = NoExt
 type instance XRecordCon     GhcTc = RecordConTc
+type instance XRecordCon     GhcSe = NoExt
 
 type instance XRecordUpd     GhcPs = NoExt
 type instance XRecordUpd     GhcRn = NoExt
 type instance XRecordUpd     GhcTc = RecordUpdTc
+type instance XRecordUpd     GhcSe = NoExt
 
 type instance XExprWithTySig GhcPs = (LHsSigWcType GhcPs)
 type instance XExprWithTySig GhcRn = (LHsSigWcType GhcRn)
 type instance XExprWithTySig GhcTc = (LHsSigWcType GhcRn)
+type instance XExprWithTySig GhcSe = (LHsSigWcType GhcSe)
 
 type instance XArithSeq      GhcPs = NoExt
 type instance XArithSeq      GhcRn = NoExt
 type instance XArithSeq      GhcTc = PostTcExpr
+type instance XArithSeq      GhcSe = NoExt
 
 type instance XSCC           (GhcPass _) = NoExt
 type instance XCoreAnn       (GhcPass _) = NoExt
@@ -780,10 +794,12 @@ type instance XProc          (GhcPass _) = NoExt
 type instance XStatic        GhcPs = NoExt
 type instance XStatic        GhcRn = NameSet
 type instance XStatic        GhcTc = NameSet
+type instance XStatic        GhcSe = NoExt
 
 type instance XArrApp        GhcPs = NoExt
 type instance XArrApp        GhcRn = NoExt
 type instance XArrApp        GhcTc = Type
+type instance XArrApp        GhcSe = NoExt
 
 type instance XArrForm       (GhcPass _) = NoExt
 type instance XTick          (GhcPass _) = NoExt
@@ -820,6 +836,7 @@ type instance XPresent         (GhcPass _) = NoExt
 type instance XMissing         GhcPs = NoExt
 type instance XMissing         GhcRn = NoExt
 type instance XMissing         GhcTc = Type
+type instance XMissing         GhcSe = NoExt
 
 type instance XXTupArg         (GhcPass _) = NoExt
 
@@ -900,16 +917,19 @@ RenamedSource that the API Annotations cannot be used directly with
 RenamedSource, so this allows a simple mapping to be used based on the location.
 -}
 
-instance (p ~ GhcPass pass, OutputableBndrId p) => Outputable (HsExpr p) where
+instance (p ~ GhcPass pass, OutputableBndrId p)
+      => Outputable (HsExpr p) where
     ppr expr = pprExpr expr
 
 -----------------------
 -- pprExpr, pprLExpr, pprBinds call pprDeeper;
 -- the underscore versions do not
-pprLExpr :: (OutputableBndrId (GhcPass p)) => LHsExpr (GhcPass p) -> SDoc
+pprLExpr :: (OutputableBndrId (GhcPass p))
+         => LHsExpr (GhcPass p) -> SDoc
 pprLExpr (L _ e) = pprExpr e
 
-pprExpr :: (OutputableBndrId (GhcPass p)) => HsExpr (GhcPass p) -> SDoc
+pprExpr :: (OutputableBndrId (GhcPass p))
+        => HsExpr (GhcPass p) -> SDoc
 pprExpr e | isAtomicHsExpr e || isQuietHsExpr e =            ppr_expr e
           | otherwise                           = pprDeeper (ppr_expr e)
 
@@ -924,12 +944,13 @@ isQuietHsExpr (HsAppType {})    = True
 isQuietHsExpr (OpApp {})        = True
 isQuietHsExpr _ = False
 
-pprBinds :: (OutputableBndrId (GhcPass idL), OutputableBndrId (GhcPass idR))
+pprBinds :: ( OutputableBndrId (GhcPass idL), OutputableBndrId (GhcPass idR) )
          => HsLocalBindsLR (GhcPass idL) (GhcPass idR) -> SDoc
 pprBinds b = pprDeeper (ppr b)
 
 -----------------------
-ppr_lexpr :: (OutputableBndrId (GhcPass p)) => LHsExpr (GhcPass p) -> SDoc
+ppr_lexpr :: (OutputableBndrId (GhcPass p))
+          => LHsExpr (GhcPass p) -> SDoc
 ppr_lexpr e = ppr_expr (unLoc e)
 
 ppr_expr :: forall p. (OutputableBndrId (GhcPass p))
@@ -1439,16 +1460,19 @@ type instance XCmdTop  GhcTc = CmdTopTc
 
 type instance XXCmdTop (GhcPass _) = NoExt
 
-instance (p ~ GhcPass pass, OutputableBndrId p) => Outputable (HsCmd p) where
-    ppr cmd = pprCmd cmd
+instance (p ~ GhcPass pass, OutputableBndrId p)
+      => Outputable (HsCmd p) where
+  ppr cmd = pprCmd cmd
 
 -----------------------
 -- pprCmd and pprLCmd call pprDeeper;
 -- the underscore versions do not
-pprLCmd :: (OutputableBndrId (GhcPass p)) => LHsCmd (GhcPass p) -> SDoc
+pprLCmd :: (OutputableBndrId (GhcPass p))
+        => LHsCmd (GhcPass p) -> SDoc
 pprLCmd (L _ c) = pprCmd c
 
-pprCmd :: (OutputableBndrId (GhcPass p)) => HsCmd (GhcPass p) -> SDoc
+pprCmd :: (OutputableBndrId (GhcPass p))
+       => HsCmd (GhcPass p) -> SDoc
 pprCmd c | isQuietHsCmd c =            ppr_cmd c
          | otherwise      = pprDeeper (ppr_cmd c)
 
@@ -1462,10 +1486,12 @@ isQuietHsCmd (HsCmdApp {}) = True
 isQuietHsCmd _ = False
 
 -----------------------
-ppr_lcmd :: (OutputableBndrId (GhcPass p)) => LHsCmd (GhcPass p) -> SDoc
+ppr_lcmd :: (OutputableBndrId (GhcPass p))
+         => LHsCmd (GhcPass p) -> SDoc
 ppr_lcmd c = ppr_cmd (unLoc c)
 
-ppr_cmd :: forall p. (OutputableBndrId (GhcPass p)) => HsCmd (GhcPass p) -> SDoc
+ppr_cmd :: forall p. (OutputableBndrId (GhcPass p))
+        => HsCmd (GhcPass p) -> SDoc
 ppr_cmd (HsCmdPar _ c) = parens (ppr_lcmd c)
 
 ppr_cmd (HsCmdApp _ c e)
@@ -1527,12 +1553,14 @@ ppr_cmd (HsCmdArrForm _ op _ _ args)
          4 (sep (map (pprCmdArg.unLoc) args) <> text "|)")
 ppr_cmd (XCmd x) = ppr x
 
-pprCmdArg :: (OutputableBndrId (GhcPass p)) => HsCmdTop (GhcPass p) -> SDoc
+pprCmdArg :: (OutputableBndrId (GhcPass p))
+          => HsCmdTop (GhcPass p) -> SDoc
 pprCmdArg (HsCmdTop _ cmd)
   = ppr_lcmd cmd
 pprCmdArg (XCmdTop x) = ppr x
 
-instance (p ~ GhcPass pass, OutputableBndrId p) => Outputable (HsCmdTop p) where
+instance (p ~ GhcPass pass, OutputableBndrId p)
+      => Outputable (HsCmdTop p) where
     ppr = pprCmdArg
 
 {-
@@ -1586,6 +1614,7 @@ data MatchGroupTc
 type instance XMG         GhcPs b = NoExt
 type instance XMG         GhcRn b = NoExt
 type instance XMG         GhcTc b = MatchGroupTc
+type instance XMG         GhcSe b = NoExt
 
 type instance XXMatchGroup (GhcPass _) b = NoExt
 
@@ -1609,7 +1638,7 @@ type instance XCMatch (GhcPass _) b = NoExt
 type instance XXMatch (GhcPass _) b = NoExt
 
 instance (idR ~ GhcPass pr, OutputableBndrId idR, Outputable body)
-            => Outputable (Match idR body) where
+      => Outputable (Match idR body) where
   ppr = pprMatch
 
 {-
@@ -1985,20 +2014,24 @@ type instance XLastStmt        (GhcPass _) (GhcPass _) b = NoExt
 type instance XBindStmt        (GhcPass _) GhcPs b = NoExt
 type instance XBindStmt        (GhcPass _) GhcRn b = NoExt
 type instance XBindStmt        (GhcPass _) GhcTc b = Type
+type instance XBindStmt        (GhcPass _) GhcSe b = NoExt
 
 type instance XApplicativeStmt (GhcPass _) GhcPs b = NoExt
 type instance XApplicativeStmt (GhcPass _) GhcRn b = NoExt
 type instance XApplicativeStmt (GhcPass _) GhcTc b = Type
+type instance XApplicativeStmt (GhcPass _) GhcSe b = NoExt
 
 type instance XBodyStmt        (GhcPass _) GhcPs b = NoExt
 type instance XBodyStmt        (GhcPass _) GhcRn b = NoExt
 type instance XBodyStmt        (GhcPass _) GhcTc b = Type
+type instance XBodyStmt        (GhcPass _) GhcSe b = NoExt
 
 type instance XLetStmt         (GhcPass _) (GhcPass _) b = NoExt
 
 type instance XParStmt         (GhcPass _) GhcPs b = NoExt
 type instance XParStmt         (GhcPass _) GhcRn b = NoExt
 type instance XParStmt         (GhcPass _) GhcTc b = Type
+type instance XParStmt         (GhcPass _) GhcSe b = NoExt
 
 type instance XTransStmt       (GhcPass _) GhcPs b = NoExt
 type instance XTransStmt       (GhcPass _) GhcRn b = NoExt
@@ -2007,6 +2040,7 @@ type instance XTransStmt       (GhcPass _) GhcTc b = Type
 type instance XRecStmt         (GhcPass _) GhcPs b = NoExt
 type instance XRecStmt         (GhcPass _) GhcRn b = NoExt
 type instance XRecStmt         (GhcPass _) GhcTc b = RecStmtTc
+type instance XRecStmt         (GhcPass _) GhcSe b = NoExt
 
 type instance XXStmtLR         (GhcPass _) (GhcPass _) b = NoExt
 
@@ -2219,9 +2253,8 @@ instance (Outputable (StmtLR idL idL (LHsExpr idL)),
   ppr (ParStmtBlock _ stmts _ _) = interpp'SP stmts
   ppr (XParStmtBlock x)          = ppr x
 
-instance (idL ~ GhcPass pl,idR ~ GhcPass pr,
-          OutputableBndrId idL, OutputableBndrId idR,
-          Outputable body)
+instance (idL ~ GhcPass pl, idR ~ GhcPass pr,
+          OutputableBndrId idL, OutputableBndrId idR, Outputable body)
          => Outputable (StmtLR idL idR body) where
     ppr stmt = pprStmt stmt
 
@@ -2529,20 +2562,21 @@ sense, although I hate to add another constructor to HsExpr.
 -}
 
 instance (p ~ GhcPass pass, OutputableBndrId p)
-       => Outputable (HsSplicedThing p) where
+      => Outputable (HsSplicedThing p) where
   ppr (HsSplicedExpr e) = ppr_expr e
   ppr (HsSplicedTy   t) = ppr t
   ppr (HsSplicedPat  p) = ppr p
 
-instance (p ~ GhcPass pass, OutputableBndrId p) => Outputable (HsSplice p) where
+instance (p ~ GhcPass pass, OutputableBndrId p)
+      => Outputable (HsSplice p) where
   ppr s = pprSplice s
 
 pprPendingSplice :: (OutputableBndrId (GhcPass p))
                  => SplicePointName -> LHsExpr (GhcPass p) -> SDoc
 pprPendingSplice n e = angleBrackets (ppr n <> comma <+> ppr e)
 
-pprSpliceDecl ::  (OutputableBndrId (GhcPass p))
-          => HsSplice (GhcPass p) -> SpliceExplicitFlag -> SDoc
+pprSpliceDecl :: (OutputableBndrId (GhcPass p))
+              => HsSplice (GhcPass p) -> SpliceExplicitFlag -> SDoc
 pprSpliceDecl e@HsQuasiQuote{} _ = pprSplice e
 pprSpliceDecl e ExplicitSplice   = text "$(" <> ppr_splice_decl e <> text ")"
 pprSpliceDecl e ImplicitSplice   = ppr_splice_decl e
@@ -2552,7 +2586,8 @@ ppr_splice_decl :: (OutputableBndrId (GhcPass p))
 ppr_splice_decl (HsUntypedSplice _ _ n e) = ppr_splice empty n e empty
 ppr_splice_decl e = pprSplice e
 
-pprSplice :: (OutputableBndrId (GhcPass p)) => HsSplice (GhcPass p) -> SDoc
+pprSplice :: (OutputableBndrId (GhcPass p))
+          => HsSplice (GhcPass p) -> SDoc
 pprSplice (HsTypedSplice _ HasParens  n e)
   = ppr_splice (text "$$(") n e (text ")")
 pprSplice (HsTypedSplice _ HasDollar n e)
@@ -2609,7 +2644,8 @@ instance (p ~ GhcPass pass, OutputableBndrId p)
   ppr = pprHsBracket
 
 
-pprHsBracket :: (OutputableBndrId (GhcPass p)) => HsBracket (GhcPass p) -> SDoc
+pprHsBracket :: (OutputableBndrId (GhcPass p))
+             => HsBracket (GhcPass p) -> SDoc
 pprHsBracket (ExpBr _ e)   = thBrackets empty (ppr e)
 pprHsBracket (PatBr _ p)   = thBrackets (char 'p') (ppr p)
 pprHsBracket (DecBrG _ gp) = thBrackets (char 'd') (ppr gp)
@@ -2722,6 +2758,38 @@ instance OutputableBndr id => Outputable (HsMatchContext id) where
   ppr ThPatQuote            = text "ThPatQuote"
   ppr PatSyn                = text "PatSyn"
 
+{-
+instance Binary id => Binary (HsMatchContext id) where
+  put_ bh c = case c of
+    FunRhs a b c  -> putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    LambdaExpr    -> putByte bh 1
+    CaseAlt       -> putByte bh 2
+    IfAlt         -> putByte bh 3
+    ProcExpr      -> putByte bh 4
+    PatBindRhs    -> putByte bh 5
+    PatBindGuards -> putByte bh 6
+    RecUpd        -> putByte bh 7
+    StmtCtxt a    -> putByte bh 8 >> put_ bh a
+    ThPatSplice   -> putByte bh 9
+    ThPatQuote    -> putByte bh 10
+    PatSyn        -> putByte bh 11
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0  -> FunRhs <$> get bh <*> get bh <*> get bh
+      1  -> pure LambdaExpr
+      2  -> pure CaseAlt
+      3  -> pure IfAlt
+      4  -> pure ProcExpr
+      5  -> pure PatBindRhs
+      6  -> pure PatBindGuards
+      7  -> pure RecUpd
+      8  -> StmtCtxt <$> get bh
+      9  -> pure ThPatSplice
+      10 -> pure ThPatQuote
+      _  -> pure PatSyn
+-}
+
 isPatSynCtxt :: HsMatchContext id -> Bool
 isPatSynCtxt ctxt =
   case ctxt of
@@ -2745,6 +2813,34 @@ data HsStmtContext id
   deriving Functor
 deriving instance (Data id) => Data (HsStmtContext id)
 
+{-
+instance Binary (HsMatchContext id) => Binary (HsStmtContext id) where
+  put_ bh c = case c of
+    ListComp -> putByte bh 0
+    MonadComp -> putByte bh 1
+    PArrComp -> putByte bh 2
+    DoExpr -> putByte bh 3
+    MDoExpr -> putByte bh 4
+    ArrowExpr -> putByte bh 5
+    GhciStmtCtxt -> putByte bh 6
+    PatGuard m -> putByte bh 7 >> put_ bh m
+    ParStmtCtxt c -> putByte bh 8 >> put_ bh c
+    TransStmtCtxt c -> putByte bh 9 >> put_ bh c
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure ListComp
+      1 -> pure MonadComp
+      2 -> pure PArrComp
+      3 -> pure DoExpr
+      4 -> pure MDoExpr
+      5 -> pure ArrowExpr
+      6 -> pure GhciStmtCtxt
+      7 -> PatGuard <$> get bh
+      8 -> ParStmtCtxt <$> get bh
+      _ -> TransStmtCtxt <$> get bh
+-}
+
 isListCompExpr :: HsStmtContext id -> Bool
 -- Uses syntax [ e | quals ]
 isListCompExpr ListComp          = True
diff --git a/compiler/hsSyn/HsExpr.hs-boot b/compiler/hsSyn/HsExpr.hs-boot
index 109e9814e5..701151bbea 100644
--- a/compiler/hsSyn/HsExpr.hs-boot
+++ b/compiler/hsSyn/HsExpr.hs-boot
@@ -33,14 +33,17 @@ instance (p ~ GhcPass pass, OutputableBndrId p) => Outputable (HsCmd p)
 
 type LHsExpr a = Located (HsExpr a)
 
-pprLExpr :: (OutputableBndrId (GhcPass p)) => LHsExpr (GhcPass p) -> SDoc
+pprLExpr :: (OutputableBndrId (GhcPass p))
+	 => LHsExpr (GhcPass p) -> SDoc
 
-pprExpr :: (OutputableBndrId (GhcPass p)) => HsExpr (GhcPass p) -> SDoc
+pprExpr :: (OutputableBndrId (GhcPass p))
+	=> HsExpr (GhcPass p) -> SDoc
 
-pprSplice :: (OutputableBndrId (GhcPass p)) => HsSplice (GhcPass p) -> SDoc
+pprSplice :: (OutputableBndrId (GhcPass p))
+	  => HsSplice (GhcPass p) -> SDoc
 
 pprSpliceDecl ::  (OutputableBndrId (GhcPass p))
-          => HsSplice (GhcPass p) -> SpliceExplicitFlag -> SDoc
+              => HsSplice (GhcPass p) -> SpliceExplicitFlag -> SDoc
 
 pprPatBind :: forall bndr p body. (OutputableBndrId (GhcPass bndr),
                                    OutputableBndrId (GhcPass p),
diff --git a/compiler/hsSyn/HsExprBin.hs b/compiler/hsSyn/HsExprBin.hs
new file mode 100644
index 0000000000..e369759f4d
--- /dev/null
+++ b/compiler/hsSyn/HsExprBin.hs
@@ -0,0 +1,94 @@
+module HsExprBin
+  ( getModuleSplicesPath
+  , whenSet
+  , HsSpliceData(..)
+  , nonEmptyHsSpliceData
+  , emptyHsSpliceData
+  , SpliceResult(..)
+  , recordSpliceResult
+  , lookupSpliceResult
+  , exprSE2PS
+  , declSE2PS
+  , exprPS2SE
+  , declPS2SE
+  ) where
+
+import Binary
+import GhcPrelude
+-- split into several modules because it was otherwise taking
+-- too long and too much memory to compile.
+import HsDecls
+import HsExpr
+import HsExprBin_Conversions
+import HsExprBin_Instances ()
+import HsExtension
+import Module
+import Outputable
+import SrcLoc
+import TcRnTypes
+
+import qualified Data.Map.Strict as Map
+import System.FilePath
+
+-- * .hs-splice file contents
+
+getModuleSplicesPath :: FilePath -> Module -> FilePath
+getModuleSplicesPath splicesDir m = splicesDir
+  </> toPath (moduleNameString (moduleName m)) <.> "hs-splice"
+
+  where toPath = map (\c -> if c == '.' then '/' else c)
+
+whenSet :: Monad m => Maybe a -> (a -> m b) -> m b -> m b
+whenSet m j n = maybe n j m
+
+newtype HsSpliceData = HsSpliceData { hsSpliceMap :: Map.Map SrcSpan SpliceResult }
+
+emptyHsSpliceData :: HsSpliceData
+emptyHsSpliceData = HsSpliceData Map.empty
+
+nonEmptyHsSpliceData :: HsSpliceData -> Bool
+nonEmptyHsSpliceData = not . Map.null . hsSpliceMap
+
+data SpliceResult
+  = SRExpr  (LHsExpr GhcSe)
+  | SRDecls [LHsDecl GhcSe] -- TODO: change to group
+  -- TODO: add patterns and types
+
+instance Binary SpliceResult where
+  put_ bh r = case r of
+    SRExpr e -> putByte bh 0 >> put_ bh e
+    SRDecls ds -> putByte bh 1 >> put_ bh ds
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> SRExpr <$> get bh
+      1 -> SRDecls <$> get bh
+      _ -> panic "Binary SpliceResult: unknown tag"
+
+instance Binary HsSpliceData where
+  put_ bh (HsSpliceData m) = put_ bh (Map.toList m)
+  get bh = (\l -> HsSpliceData (Map.fromList l)) <$> get bh
+
+recordSpliceResult :: SrcSpan -> SpliceResult -> HsSpliceData -> HsSpliceData
+recordSpliceResult loc res (HsSpliceData m) = HsSpliceData (Map.insert loc res m)
+
+lookupSpliceResult :: SrcSpan -> HsSpliceData -> Maybe SpliceResult
+lookupSpliceResult loc (HsSpliceData m) = Map.lookup loc m
+
+-- * High-level conversion interface
+
+-- * Converting Se -> Ps
+
+exprSE2PS :: LHsExpr GhcSe -> RnM (LHsExpr GhcPs)
+exprSE2PS = cvLHsExpr
+
+declSE2PS :: LHsDecl GhcSe -> RnM (LHsDecl GhcPs)
+declSE2PS = cvLHsDecl
+
+-- * Converting Ps -> Se
+
+exprPS2SE :: LHsExpr GhcPs -> RnM (LHsExpr GhcSe)
+exprPS2SE = cvLHsExpr
+
+declPS2SE :: LHsDecl GhcPs -> RnM (LHsDecl GhcSe)
+declPS2SE = cvLHsDecl
diff --git a/compiler/hsSyn/HsExprBin.hs-boot b/compiler/hsSyn/HsExprBin.hs-boot
new file mode 100644
index 0000000000..964847e097
--- /dev/null
+++ b/compiler/hsSyn/HsExprBin.hs-boot
@@ -0,0 +1,4 @@
+module HsExprBin where
+
+data HsSpliceData
+emptyHsSpliceData :: HsSpliceData
\ No newline at end of file
diff --git a/compiler/hsSyn/HsExprBin_Conversions.hs b/compiler/hsSyn/HsExprBin_Conversions.hs
new file mode 100644
index 0000000000..f8bfd42b96
--- /dev/null
+++ b/compiler/hsSyn/HsExprBin_Conversions.hs
@@ -0,0 +1,933 @@
+{-# LANGUAGE ConstraintKinds #-}
+{-# LANGUAGE FlexibleContexts, FlexibleInstances #-}
+{-# LANGUAGE MultiParamTypeClasses #-}
+{-# LANGUAGE TypeFamilies, TypeSynonymInstances #-}
+module HsExprBin_Conversions where
+
+import Control.Applicative
+import Control.Monad
+import Data.Maybe
+import Data.Traversable
+
+import Bag (mapBagM)
+import Class
+import GhcPrelude
+import HsBinds
+import HsDecls
+import HsExpr
+import HsExtension
+import HsLit
+import HsPat
+import HsTypes
+import Name
+import Outputable
+import PlaceHolder
+import RdrName
+import SeName
+import SrcLoc
+import TcRnTypes
+import IfaceType
+import ToIface (toIfaceType)
+import TyCoRep (Type(..), TyLit(..))
+
+-- * Conversion utilities
+
+class ConvertType t u where
+  convertType :: t -> u
+
+class ConvertName a b where
+  convertName :: a -> b
+
+instance ConvertName a b => ConvertName [a] [b] where
+  convertName = fmap convertName
+
+instance ConvertName a b => ConvertName (Either e a) (Either e b) where
+  convertName = fmap convertName
+
+instance ConvertName a b => ConvertName (HsMatchContext a) (HsMatchContext b) where
+  convertName = fmap convertName
+
+instance ConvertName a b => ConvertName (HsStmtContext a) (HsStmtContext b) where
+  convertName = fmap convertName
+
+instance ConvertName a b => ConvertName (Maybe a) (Maybe b) where
+  convertName = fmap convertName
+
+instance ConvertType Type IfaceType where
+  convertType = toIfaceType
+
+instance ConvertType IfaceType Type where
+  convertType (IfaceLitTy n) = LitTy (go n)
+    where go (IfaceNumTyLit a) = NumTyLit a
+          go (IfaceStrTyLit a) = StrTyLit a
+  convertType _ = panic "convertType :: IfaceType -> Type: unsupported constructor"
+
+instance ConvertName RdrName SeName where
+  convertName = mkSeName
+
+instance ConvertName SeName RdrName where
+  convertName (SeName n) = n
+
+instance ConvertName Name SeName where
+  convertName n = mkSeName (nameRdrName n)
+
+instance ConvertName SeName Name where
+  convertName (SeName n) = case isExact_maybe n of
+    Just a -> a
+    _      -> panic "convertName :: SeName -> Name: non exact RdrName in SeName"
+
+instance ConvertName a b => ConvertName (Located a) (Located b) where
+  convertName = fmap convertName
+
+type TypeConstraints p q =
+  ( TCS1 p q, TCS2 p q, TCS3 p q, TCS4 p q
+  , ConvertType (LitType p) (LitType q)
+  , ConvertName (IdP p) (IdP q)
+  , ConvertName (XDoName p) (XDoName q)
+  )
+
+type TCS1 p q =
+  ( XXType p ~ XXType q
+  , XWildCardTy p ~ XWildCardTy q
+  , XTyLit p ~ XTyLit q
+  , XExplicitTupleTy p ~ XExplicitTupleTy q
+  , XExplicitListTy p ~ XExplicitListTy q
+  , XBangTy p ~ XBangTy q
+  , XKindSig p ~ XKindSig q
+  , XEqTy p ~ XEqTy q
+  , XIParamTy p ~ XIParamTy q
+  , XParTy p ~ XParTy q
+  , XOpTy p ~ XOpTy q
+  , XSumTy p ~ XSumTy q
+  , XTupleTy p ~ XTupleTy q
+  , XListTy p ~ XListTy q
+  , XFunTy p ~ XFunTy q
+  , XAppTy p ~ XAppTy q
+  , XUserTyVar p ~ XUserTyVar q
+  , XKindedTyVar p ~ XKindedTyVar q
+  , XXTyVarBndr p ~ XXTyVarBndr q
+  , XAppInfix p ~ XAppInfix q
+  , XAppPrefix p ~ XAppPrefix q
+  , XXAppType p ~ XXAppType q
+  , XAppsTy p ~ XAppsTy q
+  , XTyVar p ~ XTyVar q
+  , XQualTy p ~ XQualTy q
+  , XForAllTy p ~ XForAllTy q
+  , XHsIB p (GenLocated SrcSpan (HsType p))
+      ~ XHsIB q (GenLocated SrcSpan (HsType q))
+  , XXHsImplicitBndrs p (GenLocated SrcSpan (HsType p))
+      ~ XXHsImplicitBndrs q (GenLocated SrcSpan (HsType q))
+  , XXHsWildCardBndrs p (HsImplicitBndrs p (GenLocated SrcSpan (HsType p)))
+      ~ XXHsWildCardBndrs q (HsImplicitBndrs q (GenLocated SrcSpan (HsType q)))
+  , XXHsWildCardBndrs p (GenLocated SrcSpan (HsType p))
+      ~ XXHsWildCardBndrs q (GenLocated SrcSpan (HsType q))
+  , XHsWC p (HsImplicitBndrs p (GenLocated SrcSpan (HsType p)))
+      ~ XHsWC q (HsImplicitBndrs q (GenLocated SrcSpan (HsType q)))
+  , XHsWC p (GenLocated SrcSpan (HsType p))
+      ~ XHsWC q (GenLocated SrcSpan (HsType q))
+  , XXMatch p (LHsExpr p) ~ XXMatch q (LHsExpr q)
+  , NameOrRdrName (IdP p) ~ IdP p
+  , NameOrRdrName (IdP q) ~ IdP q
+  , XCMatch p (LHsExpr p) ~ XCMatch q (LHsExpr q)
+  , XXMatchGroup p (LHsExpr p) ~ XXMatchGroup q (LHsExpr q)
+  , XMG p (LHsExpr p) ~ XMG q (LHsExpr q)
+  , XHsDoublePrim p ~ XHsDoublePrim q
+  , XHsFloatPrim p ~ XHsFloatPrim q
+  , XHsRat p ~ XHsRat q
+  , XHsInteger p ~ XHsInteger q
+  , XHsWord64Prim p ~ XHsWord64Prim q
+  , XHsInt64Prim p ~ XHsInt64Prim q
+  , XHsWordPrim p ~ XHsWordPrim q
+  , XHsIntPrim p ~ XHsIntPrim q
+  , XHsInt p ~ XHsInt q
+  , XHsStringPrim p ~ XHsStringPrim q
+  , XHsString p ~ XHsString q
+  , XHsCharPrim p ~ XHsCharPrim q
+  , XHsChar p ~ XHsChar q
+  , XOverLit p ~ XOverLit q
+  , XXOverLit p ~ XXOverLit q
+  , XXAmbiguousFieldOcc p ~ XXAmbiguousFieldOcc q
+  , XVarPat p ~ XVarPat q
+  , XLazyPat p ~ XLazyPat q
+  , XAsPat p ~ XAsPat q
+  , XParPat p ~ XParPat q
+  , XBangPat p ~ XBangPat q
+  , XTuplePat p ~ XTuplePat q
+  , XSumPat p ~ XSumPat q
+  )
+
+type TCS2 p q =
+  ( XXHsBindsLR p p ~ XXHsBindsLR q q
+  , XPatSynBind p p ~ XPatSynBind q q
+  , XVarBind p p ~ XVarBind q q
+  , XPatBind p p ~ XPatBind q q
+  , XFunBind p p ~ XFunBind q q
+  , XXIPBind p ~ XXIPBind q
+  , XIPBind p ~ XIPBind q
+  , XXHsIPBinds p ~ XXHsIPBinds q
+  , XIPBinds p ~ XIPBinds q
+  , XXStmtLR p p (LHsExpr p) ~ XXStmtLR q q (LHsExpr q)
+  , XApplicativeArgOne p ~ XApplicativeArgOne q
+  , XApplicativeArgMany p ~ XApplicativeArgMany q
+  , XXApplicativeArg p ~ XXApplicativeArg q
+  , XRecStmt p p (LHsExpr p) ~ XRecStmt q q (LHsExpr q)
+  , XLetStmt p p (LHsExpr p) ~ XLetStmt q q (LHsExpr q)
+  , XApplicativeStmt p p (LHsExpr p)
+      ~ XApplicativeStmt q q (LHsExpr q)
+  , XBodyStmt p p (LHsExpr p) ~ XBodyStmt q q (LHsExpr q)
+  , XBindStmt p p (LHsExpr p) ~ XBindStmt q q (LHsExpr q)
+  , XLastStmt p p (LHsExpr p) ~ XLastStmt q q (LHsExpr q)
+  , XXFieldOcc p ~ XXFieldOcc q
+  , XFieldOcc p ~ XFieldOcc q
+  , XXValBindsLR p p ~ NHsValBindsLR p
+  , XXValBindsLR q q ~ NHsValBindsLR q
+  , XXSig p ~ XXSig q
+  , XValBinds p p ~ XValBinds q q
+  , XXHsLocalBindsLR p p ~ XXHsLocalBindsLR q q
+  , XEmptyLocalBinds p p ~ XEmptyLocalBinds q q
+  , XHsIPBinds p p ~ XHsIPBinds q q
+  , XHsValBinds p p ~ XHsValBinds q q
+  , XXGRHS p (LHsExpr p) ~ XXGRHS q (LHsExpr q)
+  , XCGRHS p (LHsExpr p) ~ XCGRHS q (LHsExpr q)
+  , XXPat p ~ XXPat q
+  , XXGRHSs p (LHsExpr p) ~ XXGRHSs q (LHsExpr q)
+  , XCGRHSs p (LHsExpr p) ~ XCGRHSs q (LHsExpr q)
+  , XXLit p ~ XXLit q
+  , XLitPat p ~ XLitPat q
+  , XViewPat p ~ XViewPat q
+  , XSumPat p ~ XSumPat q
+  , XTuplePat p ~ XTuplePat q
+  , XBangPat p ~ XBangPat q
+  , XParPat p ~ XParPat q
+  , XAsPat p ~ XAsPat q
+  , XLazyPat p ~ XLazyPat q
+  , XVarPat p ~ XVarPat q
+  , XWildPat p ~ XWildPat q
+  , XAmbiguous p ~ XAmbiguous q
+  , XUnambiguous p ~ XUnambiguous q
+  , XXExpr p ~ XXExpr q
+  , XStatic p ~ XStatic q
+  , XCoreAnn p ~ XCoreAnn q
+  , XSCC p ~ XSCC q
+  , XArithSeq p ~ XArithSeq q
+  , XRecordUpd p ~ XRecordUpd q
+  , XRecordCon p ~ XRecordCon q
+  , XDo p ~ XDo q
+  , XLet p ~ XLet q
+  , XMultiIf p ~ XMultiIf q
+  , XIf p ~ XIf q
+  , XCase p ~ XCase q
+  )
+
+type TCS3 p q =
+  ( XExplicitList p ~ XExplicitList q
+  , XExplicitSum p ~ XExplicitSum q
+  , XSectionL p ~ XSectionL q
+  , XSectionR p ~ XSectionR q
+  , XPar p ~ XPar q
+  , XNegApp p ~ XNegApp q
+  , XOpApp p ~ XOpApp q
+  , XApp p ~ XApp q
+  , XLamCase p ~ XLamCase q
+  , XLam p ~ XLam q
+  , XLitE p ~ XLitE q
+  , XOverLitE p ~ XOverLitE q
+  , XIPVar p ~ XIPVar q
+  , XOverLabel p ~ XOverLabel q
+  , XRecFld p ~ XRecFld q
+  , XUnboundVar p ~ XUnboundVar q
+  , XVar p ~ XVar q
+  , XXDerivDecl p ~ XXDerivDecl q
+  , XCDerivDecl p ~ XCDerivDecl q
+  , XXClsInstDecl p ~ XXClsInstDecl q
+  , XCClsInstDecl p ~ XCClsInstDecl q
+  , XXInstDecl p ~ XXInstDecl q
+  , XClsInstD p ~ XClsInstD q
+  , XXHsDecl p ~ XXHsDecl q
+  , XForD p ~ XForD q
+  , XDefD p ~ XDefD q
+  , XSigD p ~ XSigD q
+  , XValD p ~ XValD q
+  , XDerivD p ~ XDerivD q
+  , XInstD p ~ XInstD q
+  , XTyClD p ~ XTyClD q
+  , XExprWithTySig p ~ LHsSigWcType p
+  , XExprWithTySig q ~ LHsSigWcType q
+  , XAppTypeE p ~ LHsWcType p
+  , XAppTypeE q ~ LHsWcType q
+  , XTypeSig p ~ XTypeSig q
+  , XInlineSig p ~ XInlineSig q
+  , XXTyClDecl p ~ XXTyClDecl q
+  , XClassDecl p ~ XClassDecl q
+  , XHsQTvs p ~ XHsQTvs q
+  , XXLHsQTyVars p ~ XXLHsQTyVars q
+  , XXFamilyDecl p ~ XXFamilyDecl q
+  , XCFamilyDecl p ~ XCFamilyDecl q
+  , XXFamilyResultSig p ~ XXFamilyResultSig q
+  , XTyVarSig p ~ XTyVarSig q
+  , XCKindSig p ~ XCKindSig q
+  , XNoSig p ~ XNoSig q
+  , XXFamEqn p (LHsQTyVars p) (Located (HsType p))
+      ~ XXFamEqn q (LHsQTyVars q) (Located (HsType q))
+  , XCFamEqn p (LHsQTyVars p) (Located (HsType p))
+      ~ XCFamEqn q (LHsQTyVars q) (Located (HsType q))
+  , XCFamEqn p (HsTyPats p) (Located (HsType p))
+      ~ XCFamEqn q (HsTyPats q) (Located (HsType q))
+  , XHsIB p (FamEqn p (HsTyPats p) (Located (HsType p)))
+      ~ XHsIB q (FamEqn q (HsTyPats q) (Located (HsType q)))
+  , XXFamEqn p (HsTyPats p) (Located (HsType p))
+      ~ XXFamEqn q (HsTyPats q) (Located (HsType q))
+  , XXHsImplicitBndrs p (FamEqn p (HsTyPats p) (Located (HsType p)))
+      ~ XXHsImplicitBndrs q (FamEqn q (HsTyPats q) (Located (HsType q)))
+  , XClassOpSig p ~ XClassOpSig q
+  , XWarning p ~ XWarning q
+  , XXWarnDecls p ~ XXWarnDecls q
+  , XWarnings p ~ XWarnings q
+  , XFamDecl p ~ XFamDecl q
+  , XWarningD p ~ XWarningD q
+  , XXWarnDecl p ~ XXWarnDecl q
+  , XXDefaultDecl p ~ XXDefaultDecl q
+  , XCDefaultDecl p ~ XCDefaultDecl q
+  )
+
+type TCS4 p q =
+  ( XDataDecl p ~ XDataDecl q
+  , XSynDecl p ~ XSynDecl q
+  , XTyFamInstD p ~ XTyFamInstD q
+  , XDataFamInstD p ~ XDataFamInstD q
+  , XXForeignDecl p ~ XXForeignDecl q
+  , XForeignExport p ~ XForeignExport q
+  , XForeignImport p ~ XForeignImport q
+  , XXHsDataDefn p ~ XXHsDataDefn q
+  , XCHsDataDefn p ~ XCHsDataDefn q
+  , XCFamEqn p (HsTyPats p) (HsDataDefn p)
+      ~ XCFamEqn q (HsTyPats q) (HsDataDefn q)
+  , XXHsDerivingClause p ~ XXHsDerivingClause q
+  , XCHsDerivingClause p ~ XCHsDerivingClause q
+  , XXConDecl p ~ XXConDecl q
+  , XConDeclH98 p ~ XConDeclH98 q
+  , XConDeclGADT p ~ XConDeclGADT q
+  , XHsIB p (FamEqn p (HsTyPats p) (HsDataDefn p))
+      ~ XHsIB q (FamEqn q (HsTyPats q) (HsDataDefn q))
+  , XXFamEqn p (HsTyPats p) (HsDataDefn p)
+      ~ XXFamEqn q (HsTyPats q) (HsDataDefn q)
+  , XXHsImplicitBndrs p (FamEqn p (HsTyPats p) (HsDataDefn p))
+      ~ XXHsImplicitBndrs q (FamEqn q (HsTyPats q) (HsDataDefn q))
+  , XXConDeclField p ~ XXConDeclField q
+  , XConDeclField p ~ XConDeclField q
+  , XExplicitTuple p ~ XExplicitTuple q
+  , XXTupArg p ~ XXTupArg q
+  , XMissing p ~ XMissing q
+  , XPresent p ~ XPresent q
+  , XXPatSynBind p p ~ XXPatSynBind q q
+  , XPSB p p ~ XPSB q q
+  , XPatSynSig p ~ XPatSynSig q
+  , XRecTy p ~ XRecTy q
+  , XNPlusKPat p ~ XNPlusKPat q
+  , XNPat p ~ XNPat q
+  , XListPat p ~ XListPat q
+  , XELazyPat p ~ XELazyPat q
+  , XEViewPat p ~ XEViewPat q
+  , XEAsPat p ~ XEAsPat q
+  , XEWildPat p ~ XEWildPat q
+  , XSigPat p ~ HsWildCardBndrs p (LHsSigType p)
+  , XSigPat q ~ HsWildCardBndrs q (LHsSigType q)
+  )
+
+-- * Actual conversion implementation
+
+-- declarations
+
+cvLHsDecl :: TypeConstraints p q => LHsDecl p -> RnM (LHsDecl q)
+cvLHsDecl = traverse cvHsDecl
+
+cvHsDecl :: TypeConstraints p q => HsDecl p -> RnM (HsDecl q)
+cvHsDecl (TyClD a b) = TyClD a <$> cvTyClDecl b
+cvHsDecl (InstD a b) = InstD a <$> cvInstDecl b
+cvHsDecl (DerivD a b) = DerivD a <$> cvDerivDecl b
+cvHsDecl (ValD a b) = ValD a <$> cvHsBindLR b
+cvHsDecl (SigD a b) = SigD a <$> cvSig b
+cvHsDecl (DefD a b) = DefD a <$> cvDefaultDecl b
+cvHsDecl (ForD a b) = ForD a <$> cvForeignDecl b
+cvHsDecl (WarningD a b) = WarningD a <$> cvWarningDecls b
+cvHsDecl (AnnD _ _) = panic "cvHsDecl: AnnD not supported"
+cvHsDecl (RuleD _ _) = panic "cvHsDecl: RuleD not supported"
+cvHsDecl (SpliceD _ _) = panic "cvHsDecl: SpliceD not supported"
+cvHsDecl (DocD _ _) = panic "cvHsDecl: DocD not supported"
+cvHsDecl (RoleAnnotD _ _) = panic "cvHsDecl: RoleAnnotD not supported"
+cvHsDecl (XHsDecl a) = pure (XHsDecl a)
+
+cvInstDecl :: TypeConstraints p q => InstDecl p -> RnM (InstDecl q)
+cvInstDecl (ClsInstD a b) = ClsInstD a <$> cvClsInstDecl b
+cvInstDecl (DataFamInstD a b) = DataFamInstD a <$> cvDataFamInstDecl b
+cvInstDecl (TyFamInstD a b) = TyFamInstD a <$> cvTyFamInstDecl b
+cvInstDecl (XInstDecl a) = pure (XInstDecl a)
+
+cvClsInstDecl :: TypeConstraints p q => ClsInstDecl p -> RnM (ClsInstDecl q)
+cvClsInstDecl (ClsInstDecl a b c d e f g) =
+  ClsInstDecl a <$> cvHsImplicitBndrs (traverse cvType) b
+                <*> mapBagM (traverse cvHsBindLR) c
+                <*> traverse (traverse cvSig) d
+                <*> traverse (traverse cvTyFamInstDecl) e
+                <*> traverse (traverse cvDataFamInstDecl) f
+                <*> pure g
+cvClsInstDecl (XClsInstDecl a) = pure (XClsInstDecl a)
+
+cvDerivDecl :: TypeConstraints p q => DerivDecl p -> RnM (DerivDecl q)
+cvDerivDecl (DerivDecl a b c d) =
+  DerivDecl a <$> cvHsSigWcType b <*> pure c <*> pure d
+cvDerivDecl (XDerivDecl a) = pure (XDerivDecl a)
+
+cvTyClDecl :: TypeConstraints p q => TyClDecl p -> RnM (TyClDecl q)
+cvTyClDecl (FamDecl a b) = FamDecl a <$> cvFamilyDecl b
+cvTyClDecl (SynDecl a b c d e) =
+  SynDecl a (convertName b) <$> cvLHsQTyVars c <*> pure d <*> traverse cvType e
+cvTyClDecl (DataDecl a b c d e) =
+  DataDecl a (convertName b) <$> cvLHsQTyVars c <*> pure d <*> cvHsDataDefn e
+cvTyClDecl (ClassDecl a b c d e f g h i j k) =
+  ClassDecl a <$> traverse (traverse (traverse cvType)) b <*> pure (convertName c)
+              <*> cvLHsQTyVars d <*> pure e <*> traverse (traverse cvFunDep) f
+              <*> traverse (traverse cvSig) g <*> mapBagM (traverse cvHsBindLR) h
+              <*> traverse (traverse cvFamilyDecl) i
+              <*> traverse (traverse $ cvFamEqn cvLHsQTyVars (traverse cvType)) j
+              <*> pure k
+cvTyClDecl (XTyClDecl a) = pure (XTyClDecl a)
+
+cvFamEqn
+  :: ( TypeConstraints p q, XXFamEqn p a b ~ XXFamEqn q c d
+     , XCFamEqn p a b ~ XCFamEqn q c d
+     )
+  => (a -> RnM c)
+  -> (b -> RnM d)
+  -> FamEqn p a b
+  -> RnM (FamEqn q c d)
+cvFamEqn goPats goRhs (FamEqn a b c d e) =
+  FamEqn a (convertName b) <$> goPats c <*> pure d <*> goRhs e
+cvFamEqn _ _ (XFamEqn a) = pure (XFamEqn a)
+
+cvFamilyDecl :: TypeConstraints p q => FamilyDecl p -> RnM (FamilyDecl q)
+cvFamilyDecl (FamilyDecl a b c d e f g) =
+  FamilyDecl a <$> cvFamilyInfo b <*> pure (convertName c) <*> cvLHsQTyVars d
+               <*> pure e <*> traverse cvFamilyResultSig f
+               <*> traverse (traverse cvInjectivityAnn) g
+cvFamilyDecl (XFamilyDecl a) = pure (XFamilyDecl a)
+
+cvInjectivityAnn
+  :: TypeConstraints p q => InjectivityAnn p -> RnM (InjectivityAnn q)
+cvInjectivityAnn (InjectivityAnn a b) =
+  pure (InjectivityAnn (convertName a) (convertName b))
+
+cvFamilyResultSig
+  :: TypeConstraints p q => FamilyResultSig p -> RnM (FamilyResultSig q)
+cvFamilyResultSig (NoSig a) = pure (NoSig a)
+cvFamilyResultSig (KindSig a b) = KindSig a <$> traverse cvType b
+cvFamilyResultSig (TyVarSig a b) = TyVarSig a <$> traverse cvHsTyVarBndr b
+cvFamilyResultSig (XFamilyResultSig a) = pure (XFamilyResultSig a)
+
+cvFamilyInfo :: TypeConstraints p q => FamilyInfo p -> RnM (FamilyInfo q)
+cvFamilyInfo DataFamily = pure DataFamily
+cvFamilyInfo OpenTypeFamily = pure OpenTypeFamily
+cvFamilyInfo (ClosedTypeFamily a) =
+  ClosedTypeFamily <$> traverse (traverse (traverse (cvFamInstEqn (traverse cvType)))) a
+
+cvFamInstEqn
+  :: ( TypeConstraints p q
+     , XXFamEqn p (HsTyPats p) a
+         ~ XXFamEqn q (HsTyPats q) b
+     , XHsIB p (FamEqn p (HsTyPats p) a)
+         ~ XHsIB q (FamEqn q (HsTyPats q) b)
+     , XCFamEqn p (HsTyPats p) a
+         ~ XCFamEqn q (HsTyPats q) b
+     , XXHsImplicitBndrs p (FamEqn p (HsTyPats p) a)
+         ~ XXHsImplicitBndrs q (FamEqn q (HsTyPats q) b)
+     )
+  => (a -> RnM b)
+  -> FamInstEqn p a
+  -> RnM (FamInstEqn q b)
+cvFamInstEqn f = cvHsImplicitBndrs (cvFamEqn (traverse (traverse cvType)) f)
+
+cvFunDep :: ConvertName a b => FunDep a -> RnM (FunDep b)
+cvFunDep (xs, ys) = pure (convertName xs, convertName ys)
+
+cvLHsQTyVars :: TypeConstraints p q => LHsQTyVars p -> RnM (LHsQTyVars q)
+cvLHsQTyVars (HsQTvs a b) = HsQTvs a <$> traverse (traverse cvHsTyVarBndr) b
+cvLHsQTyVars (XLHsQTyVars a) = pure (XLHsQTyVars a)
+
+cvForeignDecl :: TypeConstraints p q => ForeignDecl p -> RnM (ForeignDecl q)
+cvForeignDecl (ForeignImport a b c d) =
+  ForeignImport a (convertName b) <$> cvHsImplicitBndrs (traverse cvType) c
+                                  <*> pure d
+cvForeignDecl (ForeignExport a b c d) =
+  ForeignExport a (convertName b) <$> cvHsImplicitBndrs (traverse cvType) c
+                                  <*> pure d
+cvForeignDecl (XForeignDecl a) = pure (XForeignDecl a)
+
+cvDefaultDecl :: TypeConstraints p q => DefaultDecl p -> RnM (DefaultDecl q)
+cvDefaultDecl (DefaultDecl a b) = DefaultDecl a <$> traverse (traverse cvType) b
+cvDefaultDecl (XDefaultDecl a) = pure (XDefaultDecl a)
+
+cvTyFamInstDecl
+  :: TypeConstraints p q => TyFamInstDecl p -> RnM (TyFamInstDecl q)
+cvTyFamInstDecl (TyFamInstDecl d) =
+  TyFamInstDecl <$> cvFamInstEqn (traverse cvType) d
+
+cvDataFamInstDecl
+  :: TypeConstraints p q => DataFamInstDecl p -> RnM (DataFamInstDecl q)
+cvDataFamInstDecl (DataFamInstDecl d) =
+  DataFamInstDecl <$> cvFamInstEqn cvHsDataDefn d
+
+cvHsDataDefn :: TypeConstraints p q => HsDataDefn p -> RnM (HsDataDefn q)
+cvHsDataDefn (HsDataDefn a b c d e f g) =
+  HsDataDefn a b
+    <$> traverse (traverse (traverse cvType)) c <*> pure d
+    <*> traverse (traverse cvType) e
+    <*> traverse (traverse cvConDecl) f <*> cvHsDeriving g
+cvHsDataDefn (XHsDataDefn a) = pure (XHsDataDefn a)
+
+cvConDecl :: TypeConstraints p q => ConDecl p -> RnM (ConDecl q)
+cvConDecl (ConDeclGADT a b c d e f g h) =
+  ConDeclGADT a (convertName b) c
+    <$> cvLHsQTyVars d
+    <*> traverse (traverse (traverse (traverse cvType))) e
+    <*> cvHsConDeclDetails f
+    <*> traverse cvType g
+    <*> pure h
+cvConDecl (ConDeclH98 a b c d e f g) =
+  ConDeclH98 a (convertName b) c
+    <$> traverse (traverse cvHsTyVarBndr) d
+    <*> traverse (traverse (traverse (traverse cvType))) e
+    <*> cvHsConDeclDetails f
+    <*> pure g
+cvConDecl (XConDecl a) = pure (XConDecl a)
+
+cvHsDeriving :: TypeConstraints p q => HsDeriving p -> RnM (HsDeriving q)
+cvHsDeriving = traverse (traverse (traverse cvHsDerivingClause))
+
+cvHsDerivingClause
+  :: TypeConstraints p q => HsDerivingClause p -> RnM (HsDerivingClause q)
+cvHsDerivingClause (HsDerivingClause a b c) =
+  HsDerivingClause a b
+    <$> traverse (traverse (cvHsImplicitBndrs (traverse cvType))) c
+cvHsDerivingClause (XHsDerivingClause a) = pure (XHsDerivingClause a)
+
+cvHsConDeclDetails
+  :: TypeConstraints p q => HsConDeclDetails p -> RnM (HsConDeclDetails q)
+cvHsConDeclDetails =
+  cvHsConDetails (traverse cvType)
+                 (traverse (traverse (traverse cvConDeclField)))
+
+cvHsConDetails
+  :: (a -> RnM c) -> (b -> RnM d) -> HsConDetails a b -> RnM (HsConDetails c d)
+cvHsConDetails f _  (PrefixCon a) = PrefixCon <$> traverse f a
+cvHsConDetails _ g     (RecCon a) = RecCon    <$> g a
+cvHsConDetails f _ (InfixCon a b) = InfixCon  <$> f a <*> f b
+
+cvConDeclField :: TypeConstraints p q => ConDeclField p -> RnM (ConDeclField q)
+cvConDeclField (ConDeclField a b c d) =
+  ConDeclField a <$> traverse (traverse cvFieldOcc) b <*> traverse cvType c
+                 <*> pure d
+cvConDeclField (XConDeclField a) = pure (XConDeclField a)
+
+cvWarningDecls :: TypeConstraints p q => WarnDecls p -> RnM (WarnDecls q)
+cvWarningDecls (Warnings a b c) =
+  Warnings a b <$> traverse (traverse cvWarningDecl) c
+cvWarningDecls (XWarnDecls a) = pure (XWarnDecls a)
+
+cvWarningDecl :: TypeConstraints p q => WarnDecl p -> RnM (WarnDecl q)
+cvWarningDecl (Warning a b c) = pure (Warning a (convertName b) c)
+cvWarningDecl (XWarnDecl a) = pure (XWarnDecl a)
+
+-- expressions
+
+cvLHsExpr
+  :: TypeConstraints p q => LHsExpr p -> RnM (LHsExpr q)
+cvLHsExpr = traverse cvHsExpr
+
+cvHsExpr
+  :: TypeConstraints p q => HsExpr p -> RnM (HsExpr q)
+cvHsExpr e = case e of
+  HsVar xv v -> pure (HsVar xv (convertName v))
+  HsUnboundVar xv v -> pure (HsUnboundVar xv v)
+  -- we don't support HsConLikeOut
+  HsRecFld xf f -> pure (HsRecFld xf (cvAFieldOcc f))
+  HsOverLabel a b c -> pure (HsOverLabel a (convertName b) c)
+  HsIPVar a b -> pure (HsIPVar a b)
+  HsOverLit a b -> HsOverLit a <$> cvOverLit b
+  HsLit a b -> pure (HsLit a (cvLit b))
+  HsLam a b -> HsLam a <$> cvMatchGroup b
+  HsLamCase a b -> HsLamCase a <$> cvMatchGroup b
+  HsApp a b c -> HsApp a <$> cvLHsExpr b <*> cvLHsExpr c
+  HsAppType a b -> HsAppType <$> cvLHsWcType a <*> cvLHsExpr b
+  OpApp a b c d -> OpApp a <$> cvLHsExpr b <*> cvLHsExpr c <*> cvLHsExpr d
+  NegApp a b c -> NegApp a <$> cvLHsExpr b <*> cvSyntaxExpr c
+  HsPar a b -> HsPar a <$> cvLHsExpr b
+  SectionL a b c -> SectionL a <$> cvLHsExpr b <*> cvLHsExpr c
+  SectionR a b c -> SectionR a <$> cvLHsExpr b <*> cvLHsExpr c
+  ExplicitTuple a b c -> ExplicitTuple a <$> traverse (traverse cvHsTupArg) b <*> pure c
+  ExplicitSum a b c d -> ExplicitSum a b c <$> cvLHsExpr d
+  ExplicitList a b c -> ExplicitList a <$> traverse cvSyntaxExpr b <*> traverse cvLHsExpr c
+  HsCase a b c -> HsCase a <$> cvLHsExpr b <*> cvMatchGroup c
+  HsIf a b c d e -> HsIf a <$> traverse cvSyntaxExpr b
+                           <*> cvLHsExpr c <*> cvLHsExpr d <*> cvLHsExpr e
+  HsMultiIf a b -> HsMultiIf a <$> traverse (traverse cvGRHS) b
+  HsLet a b c -> HsLet a <$> traverse cvHsLocalBinds b <*> cvLHsExpr c
+  HsDo a b c -> HsDo a (convertName b) <$> traverse (traverse (traverse cvStmtLR)) c
+  RecordCon a b c -> RecordCon a (convertName b) <$> cvRecordBinds c
+  RecordUpd a b c -> RecordUpd a <$> cvLHsExpr b <*> traverse (traverse cvHsRecUpdField) c
+  ExprWithTySig a b -> ExprWithTySig <$> cvHsSigWcType a <*> cvLHsExpr b
+  ArithSeq a b c -> ArithSeq a <$> traverse cvSyntaxExpr b <*> cvArithSeqInfo c
+  HsSCC a b c d -> HsSCC a b c <$> cvLHsExpr d
+  HsCoreAnn a b c d -> HsCoreAnn a b c <$> cvLHsExpr d
+  HsStatic a b -> HsStatic a <$> cvLHsExpr b
+  EWildPat a -> pure (EWildPat a)
+  EAsPat a b c -> EAsPat a (convertName b) <$> cvLHsExpr c
+  EViewPat a b c -> EViewPat a <$> cvLHsExpr b <*> cvLHsExpr c
+  ELazyPat a b -> ELazyPat a <$> cvLHsExpr b
+
+  HsProc _ _ _ -> panic "cvHsExpr: HsProc not supported"
+  HsArrApp _ _ _ _ _ -> panic "cvHsExpr: HsArrAPp not supported"
+  HsArrForm _ _ _ _ -> panic "cvHsExpr: HsArrForm not supported"
+  HsTick _ _ _ -> panic "cvHsExpr: HsTick not supported"
+  HsBinTick _ _ _ _ -> panic "cvHsExpr: HsBinTick not supported"
+  HsTickPragma _ _ _ _ _ -> panic "cvHsExpr: HsTickPragma not supported"
+
+  -- those are deliberately not supported for good reasons
+  -- (involve typechecker types because used only later, not easily
+  --  serialisable, used to describe splices that we are not going to
+  --  encounter, etc)
+  HsConLikeOut _ _ -> panic "cvHsExpr: HsConLikeOut not supported"
+  HsWrap _ _ _ -> panic "cvHsExpr: HsWrap not supported"
+  HsBracket _ _ -> panic "cvHsExpr: HsBracket not supported"
+  HsRnBracketOut _ _ _ -> panic "cvHsExpr: HsRnBracketOut not supported"
+  HsTcBracketOut _ _ _ -> panic "cvHsExpr: HsTcBracketOut not supported"
+  HsSpliceE _ _ -> panic "cvHsExpr: HsSpliceE not supported"
+  XExpr a -> pure (XExpr a)
+
+cvArithSeqInfo :: TypeConstraints p q => ArithSeqInfo p -> RnM (ArithSeqInfo q)
+cvArithSeqInfo (From e) = From <$> cvLHsExpr e
+cvArithSeqInfo (FromThen a b) = FromThen <$> cvLHsExpr a <*> cvLHsExpr b
+cvArithSeqInfo (FromTo a b) = FromTo <$> cvLHsExpr a <*> cvLHsExpr b
+cvArithSeqInfo (FromThenTo a b c) = FromThenTo <$> cvLHsExpr a <*> cvLHsExpr b <*> cvLHsExpr c
+
+cvHsTupArg :: TypeConstraints p q => HsTupArg p -> RnM (HsTupArg q)
+cvHsTupArg (Present a e) = Present a <$> cvLHsExpr e
+cvHsTupArg (Missing a) = pure (Missing a)
+cvHsTupArg (XTupArg a) = pure (XTupArg a)
+
+cvAFieldOcc :: TypeConstraints p q => AmbiguousFieldOcc p -> AmbiguousFieldOcc q
+cvAFieldOcc (Unambiguous a b) = Unambiguous a b
+cvAFieldOcc (Ambiguous a b) = Ambiguous a b
+cvAFieldOcc (XAmbiguousFieldOcc a) = XAmbiguousFieldOcc a
+
+cvOverLit :: TypeConstraints p q => HsOverLit p -> RnM (HsOverLit q)
+cvOverLit (OverLit a b c) = OverLit a b <$> cvHsExpr c
+cvOverLit (XOverLit a) = pure (XOverLit a)
+
+cvLit :: TypeConstraints p q => HsLit p -> HsLit q
+cvLit (HsChar a b) = HsChar a b
+cvLit (HsCharPrim a b) = HsCharPrim a b
+cvLit (HsString a b) = HsString a b
+cvLit (HsStringPrim a b) = HsStringPrim a b
+cvLit (HsInt a b) = HsInt a b
+cvLit (HsIntPrim a b) = HsIntPrim a b
+cvLit (HsWordPrim a b) = HsWordPrim a b
+cvLit (HsInt64Prim a b) = HsInt64Prim a b
+cvLit (HsWord64Prim a b) = HsWord64Prim a b
+cvLit (HsInteger a b c) = HsInteger a b (convertType c) -- (toIfaceType c)
+cvLit (HsRat a b c) = HsRat a b (convertType c) -- (toIfaceType c)
+cvLit (HsFloatPrim a b) = HsFloatPrim a b
+cvLit (HsDoublePrim a b) = HsDoublePrim a b
+cvLit (XLit a) = XLit a
+
+cvMatchGroup
+  :: TypeConstraints p q
+  => MatchGroup p (LHsExpr p) -> RnM (MatchGroup q (LHsExpr q))
+cvMatchGroup (MG a b c) = MG a <$> traverse (traverse (traverse cvMatch)) b <*> pure c
+cvMatchGroup (XMatchGroup a) = pure (XMatchGroup a)
+
+cvMatch
+  :: TypeConstraints p q
+  => Match p (LHsExpr p) -> RnM (Match q (LHsExpr q))
+cvMatch (Match a b c d) = Match a (convertName b)
+                        <$> traverse (traverse cvPat) c <*> cvGRHSs d
+cvMatch (XMatch a) = pure (XMatch a)
+
+cvPat :: TypeConstraints p q => Pat p -> RnM (Pat q)
+cvPat (WildPat a) = pure (WildPat a)
+cvPat (VarPat a b) = pure (VarPat a (convertName b))
+cvPat (LazyPat a b) = LazyPat a <$> traverse cvPat b
+cvPat (AsPat a b c) = AsPat a (convertName b) <$> traverse cvPat c
+cvPat (ParPat a b) = ParPat a <$> traverse cvPat b
+cvPat (BangPat a b) = BangPat a <$> traverse cvPat b
+cvPat (ListPat a b) = ListPat a <$> traverse (traverse cvPat) b
+cvPat (TuplePat a b c) = TuplePat a <$> traverse (traverse cvPat) b <*> pure c
+cvPat (SumPat a b c d) = SumPat a <$> traverse cvPat b <*> pure c <*> pure d
+cvPat (ConPatIn a b) = ConPatIn (convertName a) <$> cvHsConPatDetails b
+cvPat (ViewPat a b c) = ViewPat a <$> cvLHsExpr b <*> traverse cvPat c
+cvPat (LitPat a b) = pure (LitPat a (cvLit b))
+cvPat (NPat a b c d) =
+  NPat a <$> traverse cvOverLit b <*> traverse cvSyntaxExpr c
+         <*> cvSyntaxExpr d
+cvPat (NPlusKPat a b c d e f) =
+  NPlusKPat a (convertName b)
+    <$> traverse cvOverLit c <*> cvOverLit d
+    <*> cvSyntaxExpr e <*> cvSyntaxExpr f
+cvPat (SigPat a b) = SigPat <$> cvHsSigWcType a <*> traverse cvPat b
+-- deliberately not supported
+cvPat (CoPat _ _ _ _) = panic "cvPat: CoPat not supported"
+cvPat (ConPatOut _ _ _ _ _ _ _) = panic "cvPat: ConPatOut not supported"
+cvPat (SplicePat _ _) = panic "cvPat: SplicePat not supported"
+cvPat (XPat a) = pure (XPat a)
+
+cvGRHSs
+  :: TypeConstraints p q
+  => GRHSs p (LHsExpr p) -> RnM (GRHSs q (LHsExpr q))
+cvGRHSs (GRHSs a b c) = GRHSs a <$> traverse (traverse cvGRHS) b
+                                <*> traverse cvHsLocalBinds c
+cvGRHSs (XGRHSs a) = pure (XGRHSs a)
+
+cvGRHS
+  :: TypeConstraints p q
+  => GRHS p (LHsExpr p) -> RnM (GRHS q (LHsExpr q))
+cvGRHS (GRHS a b c) = GRHS a <$> traverse (traverse cvStmtLR) b <*> cvLHsExpr c
+cvGRHS (XGRHS a) = pure (XGRHS a)
+
+cvHsLocalBinds
+  :: TypeConstraints p q
+  => HsLocalBinds p -> RnM (HsLocalBinds q)
+cvHsLocalBinds (HsValBinds a b) = HsValBinds a <$> cvHsValBindsLR b
+cvHsLocalBinds (HsIPBinds a b) = HsIPBinds a <$> cvHsIPBinds b
+cvHsLocalBinds (EmptyLocalBinds a) = pure (EmptyLocalBinds a)
+cvHsLocalBinds (XHsLocalBindsLR a) = pure (XHsLocalBindsLR a)
+
+cvHsValBindsLR
+  :: TypeConstraints p q
+  => HsValBindsLR p p -> RnM (HsValBindsLR q q)
+cvHsValBindsLR (ValBinds a b c) = ValBinds a <$> mapBagM (traverse cvHsBindLR) b
+                                               <*> traverse (traverse cvSig) c
+cvHsValBindsLR (XValBindsLR a) = XValBindsLR <$> cvNHsValBindsLR a
+
+cvHsConPatDetails
+  :: TypeConstraints p q => HsConPatDetails p -> RnM (HsConPatDetails q)
+cvHsConPatDetails (PrefixCon a) = PrefixCon <$> traverse (traverse cvPat) a
+cvHsConPatDetails (RecCon a) = RecCon <$> cvHsRecFieldsPat a
+cvHsConPatDetails (InfixCon a b) = InfixCon <$> traverse cvPat a
+                                              <*> traverse cvPat b
+
+cvHsRecFields
+  :: TypeConstraints p q
+  => (thing -> RnM thing')
+  -> HsRecFields p thing
+  -> RnM (HsRecFields q thing')
+cvHsRecFields f (HsRecFields a b) =
+  HsRecFields <$> traverse (traverse (cvHsRecField' cvFieldOcc f)) a <*> pure b
+
+cvHsRecField'
+  :: (id -> RnM id')
+  -> (thing -> RnM thing')
+  -> HsRecField' id thing
+  -> RnM (HsRecField' id' thing')
+cvHsRecField' f g (HsRecField a b c) =
+  HsRecField <$> traverse f a <*> g b <*> pure c
+
+cvHsRecFieldsPat
+  :: TypeConstraints p q
+  => HsRecFields p (LPat p) -> RnM (HsRecFields q (LPat q))
+cvHsRecFieldsPat = cvHsRecFields (traverse cvPat)
+
+cvHsRecUpdField
+  :: TypeConstraints p q => HsRecUpdField p -> RnM (HsRecUpdField q)
+cvHsRecUpdField = cvHsRecField' (\x -> pure (cvAFieldOcc x)) cvLHsExpr
+
+cvRecordBinds
+  :: TypeConstraints p q => HsRecordBinds p -> RnM (HsRecordBinds q)
+cvRecordBinds = cvHsRecFields cvLHsExpr
+
+cvFieldOcc :: TypeConstraints p q => FieldOcc p -> RnM (FieldOcc q)
+cvFieldOcc (FieldOcc a b) = pure (FieldOcc a b)
+cvFieldOcc (XFieldOcc a) = pure (XFieldOcc a)
+
+cvStmtLR
+  :: TypeConstraints p q
+  => StmtLR p p (LHsExpr p) -> RnM (StmtLR q q (LHsExpr q))
+cvStmtLR (LastStmt a b c d) = LastStmt a <$> cvLHsExpr b <*> pure c <*> cvSyntaxExpr d
+cvStmtLR (BindStmt a b c d e) = BindStmt a <$> traverse cvPat b <*> cvLHsExpr c
+                                           <*> cvSyntaxExpr d <*> cvSyntaxExpr e
+cvStmtLR (BodyStmt a b c d) = BodyStmt a <$> cvLHsExpr b <*> cvSyntaxExpr c
+                                         <*> cvSyntaxExpr d
+cvStmtLR (ApplicativeStmt a b c) = ApplicativeStmt a
+  <$> traverse
+        (\(se, aa) -> (,) <$> cvSyntaxExpr se <*> cvApplicativeArg aa)
+        b
+  <*> traverse cvSyntaxExpr c
+cvStmtLR (LetStmt a b) = LetStmt a <$> traverse cvHsLocalBinds b
+cvStmtLR (RecStmt a b c d e f g) = RecStmt a
+  <$> traverse (traverse cvStmtLR) b
+  <*> pure (convertName c)
+  <*> pure (convertName d)
+  <*> cvSyntaxExpr e
+  <*> cvSyntaxExpr f
+  <*> cvSyntaxExpr g
+cvStmtLR (ParStmt _ _ _ _) = panic "cvStmtLR: ParStmt not supported yet"
+cvStmtLR (TransStmt _ _ _ _ _ _ _ _ _) = panic "cvStmtLR: TransStmt not supported yet"
+cvStmtLR (XStmtLR a) = pure (XStmtLR a)
+
+cvSyntaxExpr :: TypeConstraints p q => SyntaxExpr p -> RnM (SyntaxExpr q)
+cvSyntaxExpr (SyntaxExpr a b c) =
+  SyntaxExpr <$> cvHsExpr a <*> pure b <*> pure c
+
+cvHsIPBinds
+  :: TypeConstraints p q => HsIPBinds p -> RnM (HsIPBinds q)
+cvHsIPBinds (IPBinds a b) = IPBinds a <$> traverse (traverse cvIPBind) b
+cvHsIPBinds (XHsIPBinds a) = pure (XHsIPBinds a)
+
+cvIPBind
+  :: TypeConstraints p q => IPBind p -> RnM (IPBind q)
+cvIPBind (IPBind a b c) = IPBind a (convertName b) <$> cvLHsExpr c
+cvIPBind (XCIPBind a) = pure (XCIPBind a)
+
+cvHsBindLR
+  :: TypeConstraints p q => HsBindLR p p -> RnM (HsBindLR q q)
+cvHsBindLR (FunBind a b c d e) = FunBind a (convertName b)
+  <$> cvMatchGroup c
+  <*> pure d
+  <*> pure e
+cvHsBindLR (PatBind a b c d) = PatBind a <$> traverse cvPat b
+                                         <*> cvGRHSs c
+                                         <*> pure d
+cvHsBindLR (VarBind a b c d) = VarBind a (convertName b) <$> cvLHsExpr c <*> pure d
+cvHsBindLR (AbsBinds _ _ _ _ _ _ _) = panic "cvHsBindLR: AbsBind not supported"
+cvHsBindLR (PatSynBind a b) = PatSynBind a <$> cvPatSynBind b
+cvHsBindLR (XHsBindsLR a) = pure (XHsBindsLR a)
+
+cvHsWildCardBndrs
+  :: ( XHsWC p thing ~ XHsWC q thing'
+     , XXHsWildCardBndrs p thing ~ XXHsWildCardBndrs q thing'
+     )
+  => (thing -> RnM thing')
+  -> HsWildCardBndrs p thing
+  -> RnM (HsWildCardBndrs q thing')
+cvHsWildCardBndrs thingF (HsWC a b) = HsWC a <$> thingF b
+cvHsWildCardBndrs _ (XHsWildCardBndrs a) = pure (XHsWildCardBndrs a)
+
+cvLHsWcType
+  :: TypeConstraints p q => LHsWcType p -> RnM (LHsWcType q)
+cvLHsWcType = cvHsWildCardBndrs (traverse cvType)
+
+cvHsSigWcType
+  :: TypeConstraints p q => LHsSigWcType p -> RnM (LHsSigWcType q)
+cvHsSigWcType = cvHsWildCardBndrs (cvHsImplicitBndrs (traverse cvType))
+
+cvHsImplicitBndrs
+  :: ( XHsIB p thing ~ XHsIB q thing'
+     , XXHsImplicitBndrs p thing ~ XXHsImplicitBndrs q thing'
+     )
+  => (thing -> RnM thing')
+  -> HsImplicitBndrs p thing
+  -> RnM (HsImplicitBndrs q thing')
+cvHsImplicitBndrs f (HsIB a b) = HsIB a <$> f b
+cvHsImplicitBndrs _ (XHsImplicitBndrs a) = pure (XHsImplicitBndrs a)
+
+cvType :: TypeConstraints p q => HsType p -> RnM (HsType q)
+cvType (HsForAllTy a b c) = HsForAllTy a
+                        <$> traverse (traverse cvHsTyVarBndr) b
+                        <*> traverse cvType c
+cvType (HsQualTy a b c) = HsQualTy a
+                      <$> traverse (traverse (traverse cvType)) b
+                      <*> traverse cvType c
+cvType (HsTyVar a b c) = pure (HsTyVar a b (convertName c))
+cvType (HsAppsTy a b) = HsAppsTy a <$> traverse (traverse cvHsAppType) b
+cvType (HsAppTy a b c) = HsAppTy a <$> traverse cvType b
+                                   <*> traverse cvType c
+cvType (HsFunTy a b c) = HsFunTy a <$> traverse cvType b
+                                   <*> traverse cvType c
+cvType (HsListTy a b) = HsListTy a <$> traverse cvType b
+cvType (HsTupleTy a b c) = HsTupleTy a b <$> traverse (traverse cvType) c
+cvType (HsSumTy a b) = HsSumTy a <$> traverse (traverse cvType) b
+cvType (HsOpTy a b c d) = HsOpTy a <$> traverse cvType b
+                                   <*> pure (convertName c)
+                                   <*> traverse cvType d
+cvType (HsParTy a b) = HsParTy a <$> traverse cvType b
+cvType (HsIParamTy a b c) = HsIParamTy a b <$> traverse cvType c
+cvType (HsEqTy a b c) = HsEqTy a <$> traverse cvType b
+                                 <*> traverse cvType c
+cvType (HsKindSig a b c) = HsKindSig a <$> traverse cvType b
+                                       <*> traverse cvType c
+cvType (HsSpliceTy _ _) = panic "cvType: HsSpliceTy not supported"
+cvType (HsDocTy _ _ _) = panic "cvType: HsDocTy not supported"
+cvType (HsBangTy a b c) = HsBangTy a b <$> traverse cvType c
+cvType (HsRecTy a b) = HsRecTy a <$> traverse (traverse cvConDeclField) b
+cvType (HsExplicitListTy a b c) = HsExplicitListTy a b
+                              <$> traverse (traverse cvType) c
+cvType (HsExplicitTupleTy a b) = HsExplicitTupleTy a
+                             <$> traverse (traverse cvType) b
+cvType (HsTyLit a b) = pure (HsTyLit a b)
+cvType (HsWildCardTy a) = pure (HsWildCardTy a)
+cvType (XHsType a) = pure (XHsType a)
+
+cvHsAppType
+  :: TypeConstraints p q => HsAppType p -> RnM (HsAppType q)
+cvHsAppType (HsAppInfix a b) = pure (HsAppInfix a (convertName b))
+cvHsAppType (HsAppPrefix a b) = HsAppPrefix a <$> traverse cvType b
+cvHsAppType (XAppType a) = pure (XAppType a)
+
+cvHsTyVarBndr
+  :: TypeConstraints p q => HsTyVarBndr p -> RnM (HsTyVarBndr q)
+cvHsTyVarBndr (UserTyVar a b) = pure (UserTyVar a (convertName b))
+cvHsTyVarBndr (KindedTyVar a b c) = KindedTyVar a (convertName b)
+                                <$> traverse cvType c
+cvHsTyVarBndr (XTyVarBndr a) = pure (XTyVarBndr a)
+
+cvApplicativeArg
+  :: TypeConstraints p q => ApplicativeArg p -> RnM (ApplicativeArg q)
+cvApplicativeArg (ApplicativeArgOne a b c d) =
+  ApplicativeArgOne a <$> traverse cvPat b <*> cvLHsExpr c <*> pure d
+cvApplicativeArg (ApplicativeArgMany a b c d) =
+  ApplicativeArgMany a <$> traverse (traverse cvStmtLR) b <*> cvHsExpr c
+                       <*> traverse cvPat d
+cvApplicativeArg (XApplicativeArg a) = pure (XApplicativeArg a)
+
+cvSig :: TypeConstraints p q => Sig p -> RnM (Sig q)
+cvSig (TypeSig a b c) = TypeSig a (convertName b) <$> cvHsSigWcType c
+cvSig (PatSynSig a b c) =
+  PatSynSig a (convertName b) <$> cvHsImplicitBndrs (traverse cvType) c
+cvSig (ClassOpSig a b c d) =
+  ClassOpSig a b <$> pure (convertName c) <*> cvHsImplicitBndrs (traverse cvType) d
+cvSig (IdSig _ _) = panic "cvSig: IdSig not supported yet"
+cvSig (FixSig _ _) = panic "cvSig: FixSig not supported yet"
+cvSig (InlineSig a b c) = pure (InlineSig a (convertName b) c)
+cvSig (SpecSig _ _ _ _) = panic "cvSig: SpecSig not supported yet"
+cvSig (SpecInstSig _ _ _) = panic "cvSig: SpecInstSig not supported yet"
+cvSig (MinimalSig _ _ _) = panic "cvSig: MinimalSig not supported yet"
+cvSig (SCCFunSig _ _ _ _) = panic "cvSig: SCCFunSig not supported yet"
+cvSig (CompleteMatchSig _ _ _ _) = panic "cvSig: CompleteMatchSig not supported yet"
+cvSig (XSig a) = pure (XSig a)
+
+cvPatSynBind :: TypeConstraints p q => PatSynBind p p -> RnM (PatSynBind q q)
+cvPatSynBind (PSB a b c d e) =
+  PSB a (convertName b)
+    <$> cvHsPatSynDetails (pure . convertName) c <*> traverse cvPat d
+    <*> cvHsPatSynDir e
+cvPatSynBind (XPatSynBind a) = pure (XPatSynBind a)
+
+cvHsPatSynDetails
+  :: (a -> RnM b)
+  -> HsPatSynDetails a
+  -> RnM (HsPatSynDetails b)
+cvHsPatSynDetails f =
+  cvHsConDetails f (traverse (cvRecordPatSynField f))
+
+cvRecordPatSynField
+  :: (a -> RnM b)
+  -> RecordPatSynField a
+  -> RnM (RecordPatSynField b)
+cvRecordPatSynField f (RecordPatSynField a b) =
+  RecordPatSynField <$> f a <*> f b
+
+cvHsPatSynDir :: TypeConstraints p q => HsPatSynDir p -> RnM (HsPatSynDir q)
+cvHsPatSynDir Unidirectional = pure Unidirectional
+cvHsPatSynDir ImplicitBidirectional = pure ImplicitBidirectional
+cvHsPatSynDir (ExplicitBidirectional a) = ExplicitBidirectional <$> cvMatchGroup a
+
+cvNHsValBindsLR :: NHsValBindsLR p -> RnM (NHsValBindsLR q)
+cvNHsValBindsLR _ = panic "cvNHsValBindsLR: not supported"
diff --git a/compiler/hsSyn/HsExprBin_Instances.hs b/compiler/hsSyn/HsExprBin_Instances.hs
new file mode 100644
index 0000000000..d5fff00c5f
--- /dev/null
+++ b/compiler/hsSyn/HsExprBin_Instances.hs
@@ -0,0 +1,976 @@
+-- too noisy during development...
+{-# OPTIONS_GHC -fno-warn-orphans #-}
+{-# LANGUAGE GeneralizedNewtypeDeriving #-}
+{-# LANGUAGE StandaloneDeriving #-}
+{-# LANGUAGE FlexibleContexts, FlexibleInstances #-}
+module HsExprBin_Instances where
+
+import Control.Applicative
+import Control.Monad
+
+import BasicTypes
+import Binary
+import GhcPrelude
+import HsBinds
+import HsDecls
+import HsExpr
+import HsExtension
+import HsPat
+import HsTypes
+import Name
+import Outputable
+import RdrName
+import SeName
+import TcEvidence (HsWrapper(WpHole))
+
+-- * Binary instances
+
+instance Binary NoExt where
+  put_ _ _ = return ()
+  get _ = return NoExt
+
+instance Binary (HsExpr GhcSe) where
+  put_ bh e = case e of
+    HsVar a b -> putByte bh 0 >> put_ bh a >> put_ bh b
+    HsUnboundVar a b -> putByte bh 1 >> put_ bh a >> put_ bh b
+    HsConLikeOut _ _ -> panic "Binary HsExpr.put: HsConLikeOut not supported"
+    HsRecFld a b -> putByte bh 3 >> put_ bh a >> put_ bh b
+    HsOverLabel a b c -> putByte bh 4 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsIPVar a b -> putByte bh 5 >> put_ bh a >> put_ bh b
+    HsOverLit a b -> putByte bh 6 >> put_ bh a >> put_ bh b
+    HsLit a b -> putByte bh 7 >> put_ bh a >> put_ bh b
+    HsLam a b -> putByte bh 8 >> put_ bh a >> put_ bh b
+    HsLamCase a b -> putByte bh 9 >> put_ bh a >> put_ bh b
+    HsApp a b c -> putByte bh 10 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsAppType a b -> putByte bh 11 >> put_ bh a >> put_ bh b
+    OpApp a b c d -> putByte bh 12 >> put_ bh a >> put_ bh b >> put_ bh c
+                                   >> put_ bh d
+    NegApp a b c -> putByte bh 13 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsPar a b -> putByte bh 14 >> put_ bh a >> put_ bh b
+    SectionL a b c -> putByte bh 15 >> put_ bh a >> put_ bh b >> put_ bh c
+    SectionR a b c -> putByte bh 16 >> put_ bh a >> put_ bh b >> put_ bh c
+    ExplicitTuple a b c -> putByte bh 17 >> put_ bh a >> put_ bh b >> put_ bh c
+    ExplicitSum a b c d -> putByte bh 18 >> put_ bh a >> put_ bh b >> put_ bh c
+                                         >> put_ bh d
+    HsCase a b c -> putByte bh 19 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsIf a b c d e -> putByte bh 20 >> put_ bh a >> put_ bh b >> put_ bh c
+                                    >> put_ bh d >> put_ bh e
+    HsMultiIf a b -> putByte bh 21 >> put_ bh a >> put_ bh b
+    HsLet a b c -> putByte bh 22 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsDo a b c -> putByte bh 23 >> put_ bh a >> put_ bh b >> put_ bh c
+    ExplicitList a b c -> putByte bh 24 >> put_ bh a >> put_ bh b >> put_ bh c
+    RecordCon a b c -> putByte bh 26 >> put_ bh a >> put_ bh b >> put_ bh c
+    RecordUpd a b c -> putByte bh 27 >> put_ bh a >> put_ bh b >> put_ bh c
+    ExprWithTySig a b -> putByte bh 28 >> put_ bh a >> put_ bh b
+    ArithSeq a b c -> putByte bh 29 >> put_ bh a >> put_ bh b >> put_ bh c
+    XExpr a -> putByte bh 31 >> put_ bh a
+    _ -> panic "Binary HsExpr.put: unsupported Expr constructor"
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0  -> HsVar <$> get bh <*> get bh
+      1  -> HsUnboundVar <$> get bh <*> get bh
+      -- 2  -> HsConLikeOut <$> get bh <*> get bh
+      3  -> HsRecFld <$> get bh <*> get bh
+      4  -> HsOverLabel <$> get bh <*> get bh <*> get bh
+      5  -> HsIPVar <$> get bh <*> get bh
+      6  -> HsOverLit <$> get bh <*> get bh
+      7  -> HsLit <$> get bh <*> get bh
+      8  -> HsLam <$> get bh <*> get bh
+      9  -> HsLamCase <$> get bh <*> get bh
+      10 -> HsApp <$> get bh <*> get bh <*> get bh
+      11 -> HsAppType <$> get bh <*> get bh
+      12 -> OpApp <$> get bh <*> get bh <*> get bh <*> get bh
+      13 -> NegApp <$> get bh <*> get bh <*> get bh
+      14 -> HsPar <$> get bh <*> get bh
+      15 -> SectionL <$> get bh <*> get bh <*> get bh
+      16 -> SectionR <$> get bh <*> get bh <*> get bh
+      17 -> ExplicitTuple <$> get bh <*> get bh <*> get bh
+      18 -> ExplicitSum <$> get bh <*> get bh <*> get bh <*> get bh
+      19 -> HsCase <$> get bh <*> get bh <*> get bh
+      20 -> HsIf <$> get bh <*> get bh <*> get bh <*> get bh <*> get bh
+      21 -> HsMultiIf <$> get bh <*> get bh
+      22 -> HsLet <$> get bh <*> get bh <*> get bh
+      23 -> HsDo <$> get bh <*> get bh <*> get bh
+      24 -> ExplicitList <$> get bh <*> get bh <*> get bh
+      26 -> RecordCon <$> get bh <*> get bh <*> get bh
+      27 -> RecordUpd <$> get bh <*> get bh <*> get bh
+      28 -> ExprWithTySig <$> get bh <*> get bh
+      29 -> ArithSeq <$> get bh <*> get bh <*> get bh
+      31 -> XExpr <$> get bh
+      _ -> panic "Binary HsExpr.get: unsupported Expr constructor tag"
+
+instance Binary SeName where
+  put_ bh (SeName n) = put_ bh n
+  get bh = mkSeName <$> get bh
+
+instance Binary UnboundVar where
+  put_ bh v = case v of
+    OutOfScope a b -> putByte bh 0 >> put_ bh a >> put_ bh b
+    TrueExprHole a -> putByte bh 1 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> OutOfScope <$> get bh <*> get bh
+      _ -> TrueExprHole <$> get bh
+
+instance Binary (StmtLR GhcSe GhcSe (LHsExpr GhcSe)) where
+  put_ bh s = case s of
+    LastStmt a b c d ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    BindStmt a b c d e ->
+      putByte bh 1 >> put_ bh a >> put_ bh b >> put bh c >> put_ bh d
+                   >> put_ bh e
+    ApplicativeStmt a b c ->
+      putByte bh 2 >> put_ bh a >> put_ bh b >> put_ bh c
+    BodyStmt a b c d ->
+      putByte bh 3 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    LetStmt a b ->
+      putByte bh 4 >> put_ bh a >> put_ bh b
+    ParStmt a b c d ->
+      putByte bh 5 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    -- FIXME: no support for the TransStmt constructor just yet
+    RecStmt a b c d e f g ->
+      putByte bh 7 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+                   >> put_ bh e >> put_ bh f >> put_ bh g
+    _ -> panic "unsupported StmtLR constructor"
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> LastStmt <$> get bh <*> get bh <*> get bh <*> get bh
+      1 -> BindStmt <$> get bh <*> get bh <*> get bh <*> get bh <*> get bh
+      2 -> ApplicativeStmt <$> get bh <*> get bh <*> get bh
+      3 -> BodyStmt <$> get bh <*> get bh <*> get bh <*> get bh
+      4 -> LetStmt <$> get bh <*> get bh
+      5 -> ParStmt <$> get bh <*> get bh <*> get bh <*> get bh
+      -- FIXME: 6 -> no support for TransStmt just yet
+      7 -> RecStmt <$> get bh <*> get bh <*> get bh <*> get bh <*> get bh
+                   <*> get bh <*> get bh
+      _ -> panic "Binary StmtLR.get: unknown tag"
+
+instance Binary (ApplicativeArg GhcSe) where
+  put_ bh a = case a of
+    ApplicativeArgOne a b c d ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    ApplicativeArgMany a b c d ->
+      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    XApplicativeArg a ->
+      putByte bh 2 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> ApplicativeArgOne <$> get bh <*> get bh <*> get bh <*> get bh
+      1 -> ApplicativeArgMany <$> get bh <*> get bh <*> get bh <*> get bh
+      2 -> XApplicativeArg <$> get bh
+      _ -> panic "Binary ApplicativeAr.get: unknown tag"
+
+instance Binary (ParStmtBlock GhcSe GhcSe) where
+  put_ bh b = case b of
+    ParStmtBlock a b c d ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    XParStmtBlock a ->
+      putByte bh 1 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> ParStmtBlock <$> get bh <*> get bh <*> get bh <*> get bh
+      1 -> XParStmtBlock <$> get bh
+      _ -> panic "Binary ParStmtBlock.get: unknown tag"
+
+instance Binary (SyntaxExpr GhcSe) where
+  put_ bh (SyntaxExpr a [] WpHole) = put_ bh a
+  put_ _ _ = panic "Binary SyntaxExpr.put: wrappers should be empty"
+  get bh = SyntaxExpr <$> get bh <*> pure [] <*> pure WpHole
+
+instance Binary (GRHSs GhcSe (LHsExpr GhcSe)) where
+  put_ bh g = case g of
+    GRHSs a b c -> putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    XGRHSs a -> putByte bh 0 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> GRHSs <$> get bh <*> get bh <*> get bh
+      1 -> XGRHSs <$> get bh
+      _ -> panic "Binary GRHSs.get: unknown tag"
+
+instance Binary (GRHS GhcSe (LHsExpr GhcSe)) where
+  put_ bh g = case g of
+    GRHS a b c -> putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    XGRHS a -> putByte bh 1 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> GRHS <$> get bh <*> get bh <*> get bh
+      1 -> XGRHS <$> get bh
+      _ -> panic "Binary GRHS.get: unknown tag"
+
+instance Binary (MatchGroup GhcSe (LHsExpr GhcSe)) where
+  put_ bh g = case g of
+    MG a b c -> putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    XMatchGroup a -> putByte bh 1 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> MG <$> get bh <*> get bh <*> get bh
+      1 -> XMatchGroup <$> get bh
+      _ -> panic "Binary MatchGroup.get: unknown tag"
+
+instance Binary (Match GhcSe (LHsExpr GhcSe)) where
+  put_ bh m = case m of
+    Match a b c d ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    XMatch a ->
+      putByte bh 1 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> Match <$> get bh <*> get bh <*> get bh <*> get bh
+      1 -> XMatch <$> get bh
+      _ -> panic "Binary Match.get: unknown tag"
+
+
+instance Binary (HsMatchContext SeName) where
+  put_ bh c = case c of
+    FunRhs a b c ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    LambdaExpr -> putByte bh 1
+    CaseAlt -> putByte bh 2
+    IfAlt -> putByte bh 3
+    ProcExpr -> putByte bh 4
+    PatBindRhs -> putByte bh 5
+    PatBindGuards -> putByte bh 6
+    RecUpd -> putByte bh 7
+    StmtCtxt a -> putByte bh 8 >> put_ bh a
+    ThPatSplice -> putByte bh 9
+    ThPatQuote -> putByte bh 10
+    PatSyn -> putByte bh 11
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0  -> FunRhs <$> get bh <*> get bh <*> get bh
+      1  -> pure LambdaExpr
+      2  -> pure CaseAlt
+      3  -> pure IfAlt
+      4  -> pure ProcExpr
+      5  -> pure PatBindRhs
+      6  -> pure PatBindGuards
+      7  -> pure RecUpd
+      8  -> StmtCtxt <$> get bh
+      9  -> pure ThPatSplice
+      10 -> pure ThPatQuote
+      11 -> pure PatSyn
+      _  -> panic "Binary HsMatchContext.get: unknown tag"
+
+instance Binary (HsStmtContext SeName) where
+  put_ bh c = case c of
+    ListComp        -> putByte bh 0
+    MonadComp       -> putByte bh 1
+    DoExpr          -> putByte bh 3
+    MDoExpr         -> putByte bh 4
+    ArrowExpr       -> putByte bh 5
+    GhciStmtCtxt    -> putByte bh 6
+    PatGuard a      -> putByte bh 7 >> put_ bh a
+    ParStmtCtxt a   -> putByte bh 8 >> put_ bh a
+    TransStmtCtxt a -> putByte bh 9 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure ListComp
+      1 -> pure MonadComp
+      3 -> pure DoExpr
+      4 -> pure MDoExpr
+      5 -> pure ArrowExpr
+      6 -> pure GhciStmtCtxt
+      7 -> PatGuard <$> get bh
+      8 -> ParStmtCtxt <$> get bh
+      9 -> TransStmtCtxt <$> get bh
+      _ -> panic "Binary HsStmtContext.get: unknown tag"
+
+instance Binary (ArithSeqInfo GhcSe) where
+  put_ bh i = case i of
+    From a ->
+      putByte bh 0 >> put_ bh a
+    FromThen a b ->
+      putByte bh 1 >> put_ bh a >> put_ bh b
+    FromTo a b ->
+      putByte bh 2 >> put_ bh a >> put_ bh b
+    FromThenTo a b c ->
+      putByte bh 3 >> put_ bh a >> put_ bh b >> put_ bh c
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> From <$> get bh
+      1 -> FromThen <$> get bh <*> get bh
+      2 -> FromTo <$> get bh <*> get bh
+      3 -> FromThenTo <$> get bh <*> get bh <*> get bh
+      _ -> panic "Binary ArithSeqInfo.get: unknown tag"
+
+instance Binary (HsTupArg GhcSe) where
+  put_ bh a = case a of
+    Present a b -> putByte bh 0 >> put_ bh a >> put_ bh b
+    Missing a   -> putByte bh 1 >> put_ bh a
+    XTupArg a   -> putByte bh 2 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> Present <$> get bh <*> get bh
+      1 -> Missing <$> get bh
+      2 -> XTupArg <$> get bh
+      _ -> panic "Binary HsTupArg.get: unknown tag"
+
+instance Binary (Pat GhcSe) where
+  put_ bh p = case p of
+    WildPat a ->
+      putByte bh 0 >> put_ bh a
+    VarPat a b ->
+      putByte bh 1 >> put_ bh a >> put_ bh b
+    LazyPat a b ->
+      putByte bh 2 >> put_ bh a >> put_ bh b
+    AsPat a b c ->
+      putByte bh 3 >> put_ bh a >> put_ bh b >> put_ bh c
+    ParPat a b ->
+      putByte bh 4 >> put_ bh a >> put_ bh b
+    BangPat a b ->
+      putByte bh 5 >> put_ bh a >> put_ bh b
+    ListPat a b ->
+      putByte bh 6 >> put_ bh a >> put_ bh b
+    TuplePat a b c ->
+      putByte bh 7 >> put_ bh a >> put_ bh b >> put_ bh c
+    SumPat a b c d ->
+      putByte bh 8 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    ConPatIn a b ->
+      putByte bh 10 >> put_ bh a >> put_ bh b
+    ConPatOut _ _ _ _ _ _ _ -> panic "ConPatOut should not be serialised"
+    ViewPat a b c ->
+      putByte bh 12 >> put_ bh a >> put_ bh b >> put_ bh c
+    SplicePat _ _ -> panic "SplicePat should not be serialised"
+    LitPat a b ->
+      putByte bh 14 >> put_ bh a >> put_ bh b
+    NPat a b c d ->
+      putByte bh 15 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    NPlusKPat a b c d e f ->
+      putByte bh 16 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+                    >> put_ bh e >> put_ bh f
+    SigPat a b ->
+      putByte bh 17 >> put_ bh a >> put_ bh b
+    CoPat _ _ _ _ -> panic "CoPat should not be serialised"
+    XPat a ->
+      putByte bh 19 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> WildPat <$> get bh
+      1 -> VarPat <$> get bh <*> get bh
+      2 -> LazyPat <$> get bh <*> get bh
+      3 -> AsPat <$> get bh <*> get bh <*> get bh
+      4 -> ParPat <$> get bh <*> get bh
+      5 -> BangPat <$> get bh <*> get bh
+      6 -> ListPat <$> get bh <*> get bh
+      7 -> TuplePat <$> get bh <*> get bh <*> get bh
+      8 -> SumPat <$> get bh <*> get bh <*> get bh <*> get bh
+      10 -> ConPatIn <$> get bh <*> get bh
+      -- we don't support ConPatOut
+      12 -> ViewPat <$> get bh <*> get bh <*> get bh
+      -- we don't support SplicePat
+      14 -> LitPat <$> get bh <*> get bh
+      15 -> NPat <$> get bh <*> get bh <*> get bh <*> get bh
+      16 -> NPlusKPat <$> get bh <*> get bh <*> get bh <*> get bh
+                      <*> get bh <*> get bh
+      17 -> SigPat <$> get bh <*> get bh
+      -- we don't support CoPat
+      19 -> XPat <$> get bh
+      _ -> panic "Binary (HsPat GhcSe).get: unknown tag"
+
+instance (Binary (FieldOcc a), Binary b) => Binary (HsRecFields a b) where
+  put_ bh (HsRecFields a b) = put_ bh a >> put_ bh b
+  get bh = HsRecFields <$> get bh <*> get bh
+
+instance (Binary id, Binary arg) => Binary (HsRecField' id arg) where
+  put_ bh (HsRecField a b c) = put_ bh a >> put_ bh b >> put_ bh c
+  get bh = HsRecField <$> get bh <*> get bh <*> get bh
+
+instance Binary (HsType GhcSe) where
+  put_ bh t = case t of
+    HsForAllTy a b c ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsQualTy a b c ->
+      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsTyVar a b c ->
+      putByte bh 2 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsAppsTy a b ->
+      putByte bh 3 >> put_ bh a >> put_ bh b
+    HsAppTy a b c ->
+      putByte bh 4 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsFunTy a b c ->
+      putByte bh 5 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsListTy a b ->
+      putByte bh 6 >> put_ bh a >> put_ bh b
+    HsTupleTy a b c ->
+      putByte bh 8 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsSumTy a b ->
+      putByte bh 9 >> put_ bh a >> put_ bh b
+    HsOpTy a b c d ->
+      putByte bh 10 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    HsParTy a b ->
+      putByte bh 11 >> put_ bh a >> put_ bh b
+    HsIParamTy a b c ->
+      putByte bh 12 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsEqTy a b c ->
+      putByte bh 13 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsKindSig a b c ->
+      putByte bh 14 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsSpliceTy _ _ -> panic "HsSpliceTy unsupported"
+    HsDocTy _ _ _ -> panic "HsDocTy unsupported"
+    HsBangTy a b c ->
+      putByte bh 17 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsRecTy a b ->
+      putByte bh 18 >> put_ bh a >> put_ bh b
+    HsExplicitListTy a b c ->
+      putByte bh 19 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsExplicitTupleTy a b ->
+      putByte bh 20 >> put_ bh a >> put_ bh b
+    HsTyLit a b ->
+      putByte bh 21 >> put_ bh a >> put_ bh b
+    HsWildCardTy a ->
+      putByte bh 22 >> put_ bh a
+    XHsType _ -> panic "XHsType unsupported"
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsForAllTy <$> get bh <*> get bh <*> get bh
+      1 -> HsQualTy <$> get bh <*> get bh <*> get bh
+      2 -> HsTyVar <$> get bh <*> get bh <*> get bh
+      3 -> HsAppsTy <$> get bh <*> get bh
+      4 -> HsAppTy <$> get bh <*> get bh <*> get bh
+      5 -> HsFunTy <$> get bh <*> get bh <*> get bh
+      6 -> HsListTy <$> get bh <*> get bh
+      8 -> HsTupleTy <$> get bh <*> get bh <*> get bh
+      9 -> HsSumTy <$> get bh <*> get bh
+      10 -> HsOpTy <$> get bh <*> get bh <*> get bh <*> get bh
+      11 -> HsParTy <$> get bh <*> get bh
+      12 -> HsIParamTy <$> get bh <*> get bh <*> get bh
+      13 -> HsEqTy <$> get bh <*> get bh <*> get bh
+      14 -> HsKindSig <$> get bh <*> get bh <*> get bh
+      -- 15 = HsSpliceTy, 16 = HsDocTy are not supported for now
+      17 -> HsBangTy <$> get bh <*> get bh <*> get bh
+      18 -> HsRecTy <$> get bh <*> get bh
+      19 -> HsExplicitListTy <$> get bh <*> get bh <*> get bh
+      20 -> HsExplicitTupleTy <$> get bh <*> get bh
+      21 -> HsTyLit <$> get bh <*> get bh
+      22 -> HsWildCardTy <$> get bh
+      23 -> panic "Binary HsType.get: XHsType not supported for now"
+      _  -> panic "Binary HsType.get: unknown tag"
+
+instance Binary HsTyLit where
+  put_ bh l = case l of
+    HsNumTy a b -> putByte bh 0 >> put_ bh a >> put_ bh b
+    HsStrTy a b -> putByte bh 1 >> put_ bh a >> put_ bh b
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsNumTy <$> get bh <*> get bh
+      1 -> HsStrTy <$> get bh <*> get bh
+      _ -> panic "Binary HsTyLit.get: unknown tag"
+
+instance Binary (HsAppType GhcSe) where
+  put_ bh t = case t of
+    HsAppInfix a b -> putByte bh 0 >> put_ bh a >> put_ bh b
+    HsAppPrefix a b -> putByte bh 1 >> put_ bh a >> put_ bh b
+    XAppType a -> putByte bh 2 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsAppInfix <$> get bh <*> get bh
+      1 -> HsAppPrefix <$> get bh <*> get bh
+      2 -> XAppType <$> get bh
+      _ -> panic "Binary HsAppType.get: unknown tag"
+
+deriving instance Binary HsWildCardInfo
+
+instance Binary a => Binary (HsWildCardBndrs GhcSe a) where
+  put_ bh w = case w of
+    HsWC a b -> putByte bh 0 >> put_ bh a >> put_ bh b
+    XHsWildCardBndrs a -> putByte bh 1 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsWC <$> get bh <*> get bh
+      1 -> XHsWildCardBndrs <$> get bh
+      _ -> panic "Binary HsWildCardBndrs.get: unknown tag"
+
+instance Binary a => Binary (HsImplicitBndrs GhcSe a) where
+  put_ bh b = case b of
+    HsIB a b -> putByte bh 0 >> put_ bh a >> put_ bh b
+    XHsImplicitBndrs a -> putByte bh 1 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsIB <$> get bh <*> get bh
+      1 -> XHsImplicitBndrs <$> get bh
+      _ -> panic "Binary HsImplicitBndrs.get: unknown tag"
+
+instance Binary HsIBRn where
+  put_ bh (HsIBRn a b) = put_ bh a >> put_ bh b
+  get bh = HsIBRn <$> get bh <*> get bh
+
+instance Binary Promoted where
+  put_ bh p = putByte bh (case p of
+    Promoted -> 0
+    NotPromoted -> 1)
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure Promoted
+      1 -> pure NotPromoted
+      _ -> panic "Binary Promoted.get: unknown tag"
+
+instance Binary HsTupleSort where
+  put_ bh s = putByte bh (case s of
+    HsUnboxedTuple -> 0
+    HsBoxedTuple -> 1
+    HsConstraintTuple -> 2
+    HsBoxedOrConstraintTuple -> 3)
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure HsUnboxedTuple
+      1 -> pure HsBoxedTuple
+      2 -> pure HsConstraintTuple
+      3 -> pure HsBoxedOrConstraintTuple
+      _ -> panic "Binary HsTupleSort.get: unknown tag"
+
+instance Binary (ConDeclField GhcSe) where
+  put_ bh f = case f of
+    ConDeclField a b c d ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    XConDeclField a ->
+      putByte bh 1 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> ConDeclField <$> get bh <*> get bh <*> get bh <*> get bh
+      1 -> XConDeclField <$> get bh
+      _ -> panic "Binary ConDeclField.get: unknown tag"
+
+instance Binary (FieldOcc GhcSe) where
+  put_ bh o = case o of
+    FieldOcc a b -> putByte bh 0 >> put_ bh a >> put_ bh b
+    XFieldOcc a  -> putByte bh 1 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> FieldOcc <$> get bh <*> get bh
+      1 -> XFieldOcc <$> get bh
+      _ -> panic "Binary FieldOcc.get: unknown tag"
+
+instance Binary (HsTyVarBndr GhcSe) where
+  put_ bh v = case v of
+    UserTyVar a b -> putByte bh 0 >> put_ bh a >> put_ bh b
+    KindedTyVar a b c -> putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c
+    XTyVarBndr a -> putByte bh 2 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> UserTyVar <$> get bh <*> get bh
+      1 -> KindedTyVar <$> get bh <*> get bh <*> get bh
+      2 -> XTyVarBndr <$> get bh
+      _ -> panic "Binary HsTyVarBndr.get: unknown tag"
+
+instance (Binary a, Binary b) => Binary (HsConDetails a b) where
+  put_ bh c = case c of
+    PrefixCon a -> putByte bh 0 >> put_ bh a
+    RecCon a -> putByte bh 1 >> put_ bh a
+    InfixCon a b -> putByte bh 2 >> put_ bh a >> put_ bh b
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> PrefixCon <$> get bh
+      1 -> RecCon <$> get bh
+      2 -> InfixCon <$> get bh <*> get bh
+      _ -> panic "Binary HsConDetails.get: unknown tag"
+
+instance Binary (AmbiguousFieldOcc GhcSe) where
+  put_ bh o = case o of
+    Unambiguous a b -> putByte bh 0 >> put_ bh a >> put_ bh b
+    Ambiguous a b   -> putByte bh 1 >> put_ bh a >> put_ bh b
+    XAmbiguousFieldOcc a -> putByte bh 2 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> Unambiguous <$> get bh <*> get bh
+      1 -> Ambiguous <$> get bh <*> get bh
+      2 -> XAmbiguousFieldOcc <$> get bh
+      _ -> panic "Binary AmbiguousOccField.get: unknown tag"
+
+instance Binary (LHsQTyVars GhcSe) where
+  put_ bh v = case v of
+    HsQTvs a b -> putByte bh 0 >> put_ bh a >> put_ bh b
+    XLHsQTyVars a -> putByte bh 1 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsQTvs <$> get bh <*> get bh
+      1 -> XLHsQTyVars <$> get bh
+      _ -> panic "Binary LHsQTyVars.get: unknown tag"
+
+instance Binary HsQTvsRn where
+  put_ bh (HsQTvsRn a b) = put_ bh a >> put_ bh b
+  get bh = HsQTvsRn <$> get bh <*> get bh
+
+instance Binary (Sig GhcSe) where
+  put_ bh s = case s of
+    TypeSig a b c ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    PatSynSig a b c ->
+      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c
+    ClassOpSig a b c d ->
+      putByte bh 2 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    IdSig a b ->
+      putByte bh 3 >> put_ bh a >> put_ bh b
+    FixSig a b ->
+      putByte bh 4 >> put_ bh a >> put_ bh b
+    InlineSig a b c ->
+      putByte bh 5 >> put_ bh a >> put_ bh b >> put_ bh c
+    -- MinimalSig = 6, SCCFunSig = 7, CompleteMatchSig = 8
+    XSig a ->
+      putByte bh 9 >> put_ bh a
+    _ -> panic "Binary Sig.put: unsupported constructor"
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> TypeSig <$> get bh <*> get bh <*> get bh
+      1 -> PatSynSig <$> get bh <*> get bh <*> get bh
+      2 -> ClassOpSig <$> get bh <*> get bh <*> get bh <*> get bh
+      3 -> IdSig <$> get bh <*> get bh
+      4 -> FixSig <$> get bh <*> get bh
+      5 -> InlineSig <$> get bh <*> get bh <*> get bh
+      -- 6 = MinimalSig, 7 = SCCFunSig, 8 = CompleteMatchSig
+      -- not supported yet
+      9 -> XSig <$> get bh
+      _ -> panic "Binary Sig.get: unknown tag"
+
+instance Binary (FixitySig GhcSe) where
+  put_ bh s = case s of
+    FixitySig a b c -> putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    XFixitySig a -> putByte bh 1 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> FixitySig <$> get bh <*> get bh <*> get bh
+      1 -> XFixitySig <$> get bh
+      _ -> panic "Binary FixitySig.get: unknown tag"
+
+
+instance Binary (HsBindLR GhcSe GhcSe) where
+  put_ bh b = case b of
+    -- TODO: we drop the "fun_co_fn" field (3rd), as it seems
+    --       to always be WpHole in the places where the binary
+    --       serialisation instances will be used.
+    -- TODO: we drop the "fun_tick" field (4th), as it is unlikely
+    --       to be used in our immediate use cases. Let's
+    --       return to parametrising away the 'Id' in that
+    --       field's type.
+    FunBind a b c d _ -> case d of
+      WpHole ->
+        putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+      _ ->
+        panic "Binary HsBindLR: FunBind with non-WpHole value in fun_co_fn"
+    -- TODO: same as for FunBind, we drop pat_ticks
+    PatBind a b c _ ->
+      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c
+    VarBind a b c d ->
+      putByte bh 2 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    AbsBinds _ _ _ _ _ _ _ ->
+      panic "Binary HsBindsLR.put: AbsBinds not supported"
+    PatSynBind a b ->
+      putByte bh 4 >> put_ bh a >> put_ bh b
+    XHsBindsLR a ->
+      putByte bh 5 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> FunBind <$> get bh <*> get bh <*> get bh <*> pure WpHole <*> pure []
+      1 -> PatBind <$> get bh <*> get bh <*> get bh <*> pure ([], [])
+      2 -> VarBind <$> get bh <*> get bh <*> get bh <*> get bh
+      4 -> PatSynBind <$> get bh <*> get bh
+      5 -> XHsBindsLR <$> get bh
+      _ -> panic "Binary HsBindsLR.get: unknown tag"
+
+instance Binary (PatSynBind GhcSe GhcSe) where
+  put_ bh b = case b of
+    PSB a b c d e ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+                   >> put_ bh e
+    XPatSynBind a ->
+      putByte bh 1 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> PSB <$> get bh <*> get bh <*> get bh <*> get bh <*> get bh
+      1 -> XPatSynBind <$> get bh
+      _ -> panic "Binary PatSynBind.get: unknown tag"
+
+instance Binary (HsPatSynDir GhcSe) where
+  put_ bh d = case d of
+    Unidirectional -> putByte bh 0
+    ImplicitBidirectional -> putByte bh 1
+    ExplicitBidirectional a -> putByte bh 2 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure Unidirectional
+      1 -> pure ImplicitBidirectional
+      2 -> ExplicitBidirectional <$> get bh
+      _ -> panic "Binary HsPatSynDir: unknown tag"
+
+instance Binary a => Binary (RecordPatSynField a) where
+  put_ bh (RecordPatSynField a b) = put_ bh a >> put_ bh b
+  get bh = RecordPatSynField <$> get bh <*> get bh
+
+instance Binary (HsIPBinds GhcSe) where
+  put_ bh b = case b of
+    IPBinds a b -> putByte bh 0 >> put_ bh a >> put_ bh b
+    XHsIPBinds a -> putByte bh 1 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> IPBinds <$> get bh <*> get bh
+      1 -> XHsIPBinds <$> get bh
+      _ -> panic "Binary HsIPBinds.get: unknown tag"
+
+instance Binary (IPBind GhcSe) where
+  put_ bh b = case b of
+    IPBind a b c -> putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    XCIPBind a   -> putByte bh 1 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> IPBind <$> get bh <*> get bh <*> get bh
+      1 -> XCIPBind <$> get bh
+      _ -> panic "Binary IPBind.get: unknown tag"
+
+-- * HsDecls
+
+instance Binary (HsDecl GhcSe) where
+  put_ bh d = case d of
+    TyClD a b  -> putByte bh 0 >> put_ bh a >> put_ bh b
+    InstD a b  -> putByte bh 1 >> put_ bh a >> put_ bh b
+    DerivD a b -> putByte bh 2 >> put_ bh a >> put_ bh b
+    ValD a b   -> putByte bh 3 >> put_ bh a >> put_ bh b
+    SigD a b   -> putByte bh 4 >> put_ bh a >> put_ bh b
+    _          -> panic "Binary HsDecl.put: unsupported constructor"
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> TyClD  <$> get bh <*> get bh
+      1 -> InstD  <$> get bh <*> get bh
+      2 -> DerivD <$> get bh <*> get bh
+      3 -> ValD   <$> get bh <*> get bh
+      4 -> SigD   <$> get bh <*> get bh
+      _ -> panic "Binary HsDecl.get: unsupported constructor"
+
+instance Binary (TyClDecl GhcSe) where
+  put_ bh d = case d of
+    FamDecl a b ->
+      putByte bh 0 >> put_ bh a >> put_ bh b
+    SynDecl a b c d e ->
+      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c
+                   >> put_ bh d >> put_ bh e
+    DataDecl a b c d e ->
+      putByte bh 2 >> put_ bh a >> put_ bh b >> put_ bh c
+                   >> put_ bh d >> put_ bh e
+    ClassDecl a b c d e f g h i j k ->
+      putByte bh 3 >> put_ bh a >> put_ bh b >> put_ bh c
+                   >> put_ bh d >> put_ bh e >> put_ bh f
+                   >> put_ bh g >> put_ bh h >> put_ bh i
+                   >> put_ bh j >> put_ bh k
+    XTyClDecl a ->
+      putByte bh 4 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> FamDecl <$> get bh <*> get bh
+      1 -> SynDecl <$> get bh <*> get bh <*> get bh <*> get bh <*> get bh
+      2 -> DataDecl <$> get bh <*> get bh <*> get bh <*> get bh <*> get bh
+      3 -> ClassDecl <$> get bh <*> get bh <*> get bh <*> get bh <*> get bh
+                     <*> get bh <*> get bh <*> get bh <*> get bh <*> get bh
+                     <*> get bh
+      4 -> XTyClDecl <$> get bh
+      _ -> panic "Binary TyClDecl.get: unknown tag"
+
+instance Binary DocDecl where
+  put_ bh d = case d of
+    DocCommentNext a    -> putByte bh 0 >> put_ bh a
+    DocCommentPrev a    -> putByte bh 1 >> put_ bh a
+    DocCommentNamed a b -> putByte bh 2 >> put_ bh a >> put_ bh b
+    DocGroup a b        -> putByte bh 3 >> put_ bh a >> put_ bh b
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> DocCommentNext <$> get bh
+      1 -> DocCommentPrev <$> get bh
+      2 -> DocCommentNamed <$> get bh <*> get bh
+      3 -> DocGroup <$> get bh <*> get bh
+      _ -> panic "Binary DocDecl.get: unknown tag"
+
+instance (Binary a, Binary b) => Binary (FamEqn GhcSe a b) where
+  put_ bh e = case e of
+    FamEqn a b c d e ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+                   >> put_ bh d >> put_ bh e
+    XFamEqn a ->
+      putByte bh 1 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> FamEqn <$> get bh <*> get bh <*> get bh <*> get bh <*> get bh
+      1 -> XFamEqn <$> get bh
+      _ -> panic "Binary FamEqn.get: unknown tag"
+
+instance Binary (HsDataDefn GhcSe) where
+  put_ bh d = case d of
+    HsDataDefn a b c d e f g ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+                   >> put_ bh d >> put_ bh e >> put_ bh f
+                   >> put_ bh g
+    XHsDataDefn a ->
+      putByte bh 1 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsDataDefn <$> get bh <*> get bh <*> get bh <*> get bh
+                      <*> get bh <*> get bh <*> get bh
+      1 -> XHsDataDefn <$> get bh
+      _ -> panic "Binary HsDataDefn.get: unknown tag"
+
+instance Binary NewOrData where
+  put_ bh a = putByte bh (case a of
+    NewType  -> 0
+    DataType -> 1)
+  get bh = getByte bh >>= \b -> case b of
+    0 -> pure NewType
+    1 -> pure DataType
+    _ -> panic "Binary NewOrData.get: unknown tag"
+
+instance Binary (HsDerivingClause GhcSe) where
+  put_ bh c = case c of
+    HsDerivingClause a b c ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    XHsDerivingClause a ->
+      putByte bh 1 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsDerivingClause <$> get bh <*> get bh <*> get bh
+      1 -> XHsDerivingClause <$> get bh
+      _ -> panic "Binary HsDerivingClause.get: unknown tag"
+
+instance Binary (ConDecl GhcSe) where
+  put_ _ _ = panic "Binary ConDecl: not implemented"
+  get _    = panic "Binary ConDecl: not implemented"
+
+instance Binary (FamilyDecl GhcSe) where
+  put_ _ _ = panic "Binary FamilyDecl: not implemented"
+  get _    = panic "Binary.FamilyDecl: not implemented"
+
+instance Binary (InstDecl GhcSe) where
+  put_ bh d = case d of
+    ClsInstD a b ->
+      putByte bh 0 >> put_ bh a >> put_ bh b
+    DataFamInstD a b ->
+      putByte bh 1 >> put_ bh a >> put_ bh b
+    TyFamInstD a b ->
+      putByte bh 2 >> put_ bh a >> put_ bh b
+    XInstDecl a ->
+      putByte bh 3 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> ClsInstD <$> get bh <*> get bh
+      1 -> DataFamInstD <$> get bh <*> get bh
+      2 -> TyFamInstD <$> get bh <*> get bh
+      3 -> XInstDecl <$> get bh
+      _ -> panic "Binary InstDecl.get: unknown tag"
+
+instance Binary (ClsInstDecl GhcSe) where
+  put_ bh d = case d of
+    ClsInstDecl a b c d e f g ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+                   >> put_ bh e >> put_ bh f >> put_ bh g
+    XClsInstDecl a ->
+      putByte bh 1 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> ClsInstDecl <$> get bh <*> get bh <*> get bh <*> get bh
+                       <*> get bh <*> get bh <*> get bh
+      1 -> XClsInstDecl <$> get bh
+      _ -> panic "Binary ClsInstDecl.get: unknown tag"
+
+instance Binary (DataFamInstDecl GhcSe) where
+  put_ bh (DataFamInstDecl a) = put_ bh a
+  get bh = DataFamInstDecl <$> get bh
+
+instance Binary (TyFamInstDecl GhcSe) where
+  put_ bh (TyFamInstDecl a) = put_ bh a
+  get bh = TyFamInstDecl <$> get bh
+
+instance Binary (DerivDecl GhcSe) where
+  put_ bh d = case d of
+    DerivDecl a b c d ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    XDerivDecl a ->
+      putByte bh 1 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> DerivDecl <$> get bh <*> get bh <*> get bh <*> get bh
+      1 -> XDerivDecl <$> get bh
+      _ -> panic "Binary DerivDecl.get: unknown tag"
+
+instance Binary DataDeclRn where
+  put_ bh (DataDeclRn a b) = put_ bh a >> put_ bh b
+  get bh = DataDeclRn <$> get bh <*> get bh
+
+instance Binary DerivStrategy where
+  put_ bh s = putByte bh (case s of
+    StockStrategy    -> 0
+    AnyclassStrategy -> 1
+    NewtypeStrategy  -> 2)
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure StockStrategy
+      1 -> pure AnyclassStrategy
+      2 -> pure NewtypeStrategy
+      _ -> panic "Binary DerivStrategy.get: unknown tag"
+
+instance Binary HsSrcBang where
+  put_ bh (HsSrcBang a b c) =
+    put_ bh a >> put_ bh b >> put_ bh c
+  get bh = HsSrcBang <$> get bh <*> get bh <*> get bh
+
+instance Binary RdrName where
+  put_ bh n = case n of
+    Unqual a -> putByte bh 0 >> put_ bh a
+    Qual a b -> putByte bh 1 >> put_ bh a >> put_ bh b
+    Orig a b -> putByte bh 2 >> put_ bh a >> put_ bh b
+    Exact a
+      | isExternalName a -> putByte bh 3 >> put_ bh a
+      | otherwise -> putByte bh (if isSystemName a then 4 else 5)
+          >> put_ bh (nameUnique a) >> put_ bh (nameOccName a)
+          >> put_ bh (nameSrcSpan a)
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> Unqual <$> get bh
+      1 -> Qual <$> get bh <*> get bh
+      2 -> Orig <$> get bh <*> get bh
+      3 -> Exact <$> get bh
+      4 -> fmap Exact (mkSystemNameAt <$> get bh <*> get bh <*> get bh)
+      5 -> fmap Exact (mkInternalName <$> get bh <*> get bh <*> get bh)
+      _ -> panic "Binary RdrName.get: unknown tag"
diff --git a/compiler/hsSyn/HsExtension.hs b/compiler/hsSyn/HsExtension.hs
index 4898e36e3b..e41ea9e1c2 100644
--- a/compiler/hsSyn/HsExtension.hs
+++ b/compiler/hsSyn/HsExtension.hs
@@ -23,6 +23,7 @@ import Data.Data hiding ( Fixity )
 import PlaceHolder
 import Name
 import RdrName
+import SeName
 import Var
 import Outputable
 import SrcLoc (Located)
@@ -68,20 +69,22 @@ data GhcPass (c :: Pass)
 deriving instance Eq (GhcPass c)
 deriving instance Typeable c => Data (GhcPass c)
 
-data Pass = Parsed | Renamed | Typechecked
+data Pass = Parsed | Renamed | Typechecked | Serialisable
          deriving (Data)
 
 -- Type synonyms as a shorthand for tagging
-type GhcPs   = GhcPass 'Parsed      -- Old 'RdrName' type param
-type GhcRn   = GhcPass 'Renamed     -- Old 'Name' type param
-type GhcTc   = GhcPass 'Typechecked -- Old 'Id' type para,
-type GhcTcId = GhcTc                -- Old 'TcId' type param
+type GhcPs   = GhcPass 'Parsed       -- Old 'RdrName' type param
+type GhcRn   = GhcPass 'Renamed      -- Old 'Name' type param
+type GhcTc   = GhcPass 'Typechecked  -- Old 'Id' type para,
+type GhcSe   = GhcPass 'Serialisable -- New pass, with serialisable AST representations
+type GhcTcId = GhcTc                 -- Old 'TcId' type param
 
 -- | Maps the "normal" id type for a given pass
 type family IdP p
 type instance IdP GhcPs = RdrName
 type instance IdP GhcRn = Name
 type instance IdP GhcTc = Id
+type instance IdP GhcSe = SeName
 
 type LIdP p = Located (IdP p)
 
@@ -506,6 +509,7 @@ type family XIf             x
 type family XMultiIf        x
 type family XLet            x
 type family XDo             x
+type family XDoName         x
 type family XExplicitList   x
 type family XRecordCon      x
 type family XRecordUpd      x
@@ -1111,4 +1115,9 @@ type OutputableBndrId id =
   ( OutputableBndr (NameOrRdrName (IdP id))
   , OutputableBndr (IdP id)
   , OutputableX id
+  , IdSigId id ~ Id
   )
+
+type family IdSigId pass where
+  IdSigId GhcSe       = SeName
+  IdSigId (GhcPass _) = Id
diff --git a/compiler/hsSyn/HsLit.hs b/compiler/hsSyn/HsLit.hs
index d1411bd750..f035241549 100644
--- a/compiler/hsSyn/HsLit.hs
+++ b/compiler/hsSyn/HsLit.hs
@@ -13,7 +13,7 @@
                                       -- in module PlaceHolder
 {-# LANGUAGE ConstraintKinds #-}
 {-# LANGUAGE TypeFamilies #-}
-
+{-# LANGUAGE DataKinds #-}
 module HsLit where
 
 #include "HsVersions.h"
@@ -23,6 +23,8 @@ import GhcPrelude
 import {-# SOURCE #-} HsExpr( HsExpr, pprExpr )
 import BasicTypes ( IntegralLit(..),FractionalLit(..),negateIntegralLit,
                     negateFractionalLit,SourceText(..),pprWithSourceText )
+import Binary
+import IfaceType
 import Type
 import Outputable
 import FastString
@@ -39,6 +41,10 @@ import Data.Data hiding ( Fixity )
 ************************************************************************
 -}
 
+type family LitType x where
+  LitType (GhcPass 'Serialisable) = IfaceType
+  LitType                       a = Type
+
 -- Note [Literal source text] in BasicTypes for SourceText fields in
 -- the following
 -- Note [Trees that grow] in HsExtension for the Xxxxx fields in the following
@@ -63,11 +69,11 @@ data HsLit x
       -- ^ literal @Int64#@
   | HsWord64Prim (XHsWord64Prim x) {- SourceText -} Integer
       -- ^ literal @Word64#@
-  | HsInteger (XHsInteger x) {- SourceText -} Integer Type
+  | HsInteger (XHsInteger x) {- SourceText -} Integer (LitType x)
       -- ^ Genuinely an integer; arises only
       -- from TRANSLATION (overloaded
       -- literals are done with HsOverLit)
-  | HsRat (XHsRat x)  FractionalLit Type
+  | HsRat (XHsRat x)  FractionalLit (LitType x)
       -- ^ Genuinely a rational; arises only from
       -- TRANSLATION (overloaded literals are
       -- done with HsOverLit)
@@ -109,6 +115,49 @@ instance Eq (HsLit x) where
   (HsDoublePrim _ x1) == (HsDoublePrim _ x2) = x1==x2
   _                   == _                   = False
 
+instance ( Binary (XHsChar x), Binary (XHsCharPrim x)
+         , Binary (XHsString x), Binary (XHsStringPrim x)
+         , Binary (XHsInt x), Binary (XHsIntPrim x)
+         , Binary (XHsWordPrim x), Binary (XHsInt64Prim x)
+         , Binary (XHsWord64Prim x), Binary (XHsInteger x)
+         , Binary (LitType x), Binary (XHsDoublePrim x)
+         , Binary (XHsFloatPrim x), Binary (XHsRat x)
+         , Binary (XXLit x)
+         ) => Binary (HsLit x) where
+  put_ bh lit
+    = case lit of
+        HsChar a b       -> putByte bh 0  >> put_ bh a >> put_ bh b
+        HsCharPrim a b   -> putByte bh 1  >> put_ bh a >> put_ bh b
+        HsString a b     -> putByte bh 2  >> put_ bh a >> put_ bh b
+        HsStringPrim a b -> putByte bh 3  >> put_ bh a >> put_ bh b
+        HsInt a b        -> putByte bh 4  >> put_ bh a >> put_ bh b
+        HsIntPrim a b    -> putByte bh 5  >> put_ bh a >> put_ bh b
+        HsWordPrim a b   -> putByte bh 6  >> put_ bh a >> put_ bh b
+        HsInt64Prim a b  -> putByte bh 7  >> put_ bh a >> put_ bh b
+        HsWord64Prim a b -> putByte bh 8  >> put_ bh a >> put_ bh b
+        HsInteger a b c  -> putByte bh 9  >> put_ bh a >> put_ bh b >> put_ bh c
+        HsRat a b c      -> putByte bh 10 >> put_ bh a >> put_ bh b >> put_ bh c
+        HsFloatPrim a b  -> putByte bh 11 >> put_ bh a >> put_ bh b
+        HsDoublePrim a b -> putByte bh 12 >> put_ bh a >> put_ bh b
+        XLit a           -> putByte bh 13 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0  -> HsChar       <$> get bh <*> get bh
+      1  -> HsCharPrim   <$> get bh <*> get bh
+      2  -> HsString     <$> get bh <*> get bh
+      3  -> HsStringPrim <$> get bh <*> get bh
+      4  -> HsInt        <$> get bh <*> get bh
+      5  -> HsIntPrim    <$> get bh <*> get bh
+      6  -> HsWordPrim   <$> get bh <*> get bh
+      7  -> HsInt64Prim  <$> get bh <*> get bh
+      8  -> HsWord64Prim <$> get bh <*> get bh
+      9  -> HsInteger    <$> get bh <*> get bh <*> get bh
+      10 -> HsRat        <$> get bh <*> get bh <*> get bh
+      11 -> HsFloatPrim  <$> get bh <*> get bh
+      12 -> HsDoublePrim <$> get bh <*> get bh
+      _  -> XLit         <$> get bh
+
 -- | Haskell Overloaded Literal
 data HsOverLit p
   = OverLit {
@@ -119,6 +168,18 @@ data HsOverLit p
   | XOverLit
       (XXOverLit p)
 
+instance ( Binary (HsExpr p), Binary (XOverLit p), Binary (XXOverLit p) )
+      => Binary (HsOverLit p) where
+  put_ bh lit
+    = case lit of
+        OverLit a b c -> putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+        XOverLit a    -> putByte bh 1 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> OverLit <$> get bh <*> get bh <*> get bh
+      _ -> XOverLit <$> get bh
+
 data OverLitTc
   = OverLitTc {
         ol_rebindable :: Bool, -- Note [ol_rebindable]
@@ -128,6 +189,7 @@ data OverLitTc
 type instance XOverLit GhcPs = NoExt
 type instance XOverLit GhcRn = Bool            -- Note [ol_rebindable]
 type instance XOverLit GhcTc = OverLitTc
+type instance XOverLit GhcSe = NoExt
 
 type instance XXOverLit (GhcPass _) = NoExt
 
@@ -140,6 +202,19 @@ data OverLitVal
   | HsIsString   !SourceText !FastString -- ^ String-looking literals
   deriving Data
 
+instance Binary OverLitVal where
+  put_ bh v
+    = case v of
+        HsIntegral a   -> putByte bh 0 >> put_ bh a
+        HsFractional a -> putByte bh 1 >> put_ bh a
+        HsIsString a b -> putByte bh 2 >> put_ bh a >> put_ bh b
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsIntegral <$> get bh
+      1 -> HsFractional <$> get bh
+      _ -> HsIsString <$> get bh <*> get bh
+
 negateOverLitVal :: OverLitVal -> OverLitVal
 negateOverLitVal (HsIntegral i) = HsIntegral (negateIntegralLit i)
 negateOverLitVal (HsFractional f) = HsFractional (negateFractionalLit f)
@@ -151,7 +226,7 @@ overLitType XOverLit{} = panic "overLitType"
 
 -- | Convert a literal from one index type to another, updating the annotations
 -- according to the relevant 'Convertable' instance
-convertLit :: (ConvertIdX a b) => HsLit a -> HsLit b
+convertLit :: (ConvertIdX a b, LitType a ~ LitType b) => HsLit a -> HsLit b
 convertLit (HsChar a x)       = (HsChar (convert a) x)
 convertLit (HsCharPrim a x)   = (HsCharPrim (convert a) x)
 convertLit (HsString a x)     = (HsString (convert a) x)
diff --git a/compiler/hsSyn/HsPat.hs b/compiler/hsSyn/HsPat.hs
index 866b0e2b3a..a607cb6b3f 100644
--- a/compiler/hsSyn/HsPat.hs
+++ b/compiler/hsSyn/HsPat.hs
@@ -282,6 +282,7 @@ data ListPatTc
 type instance XWildPat GhcPs = NoExt
 type instance XWildPat GhcRn = NoExt
 type instance XWildPat GhcTc = Type
+type instance XWildPat GhcSe = NoExt
 
 type instance XVarPat  (GhcPass _) = NoExt
 type instance XLazyPat (GhcPass _) = NoExt
@@ -295,18 +296,22 @@ type instance XBangPat (GhcPass _) = NoExt
 type instance XListPat GhcPs = NoExt
 type instance XListPat GhcRn = Maybe (SyntaxExpr GhcRn)
 type instance XListPat GhcTc = ListPatTc
+type instance XListPat GhcSe = NoExt
 
 type instance XTuplePat GhcPs = NoExt
 type instance XTuplePat GhcRn = NoExt
 type instance XTuplePat GhcTc = [Type]
+type instance XTuplePat GhcSe = NoExt
 
 type instance XSumPat GhcPs = NoExt
 type instance XSumPat GhcRn = NoExt
 type instance XSumPat GhcTc = [Type]
+type instance XSumPat GhcSe = NoExt
 
 type instance XViewPat GhcPs = NoExt
 type instance XViewPat GhcRn = NoExt
 type instance XViewPat GhcTc = Type
+type instance XViewPat GhcSe = NoExt
 
 type instance XSplicePat (GhcPass _) = NoExt
 type instance XLitPat    (GhcPass _) = NoExt
@@ -314,14 +319,17 @@ type instance XLitPat    (GhcPass _) = NoExt
 type instance XNPat GhcPs = NoExt
 type instance XNPat GhcRn = NoExt
 type instance XNPat GhcTc = Type
+type instance XNPat GhcSe = NoExt
 
 type instance XNPlusKPat GhcPs = NoExt
 type instance XNPlusKPat GhcRn = NoExt
 type instance XNPlusKPat GhcTc = Type
+type instance XNPlusKPat GhcSe = NoExt
 
 type instance XSigPat GhcPs = (LHsSigWcType GhcPs)
 type instance XSigPat GhcRn = (LHsSigWcType GhcRn)
 type instance XSigPat GhcTc = Type
+type instance XSigPat GhcSe = (LHsSigWcType GhcSe)
 
 type instance XCoPat  (GhcPass _) = NoExt
 type instance XXPat   (GhcPass _) = NoExt
@@ -475,7 +483,8 @@ hsRecUpdFieldOcc = fmap unambiguousFieldOcc . hsRecFieldLbl
 ************************************************************************
 -}
 
-instance (p ~ GhcPass pass, OutputableBndrId p) => Outputable (Pat p) where
+instance (p ~ GhcPass pass, OutputableBndrId p)
+      => Outputable (Pat p) where
     ppr = pprPat
 
 pprPatBndr :: OutputableBndr name => name -> SDoc
@@ -506,7 +515,8 @@ pprParendPat p pat = sdocWithDynFlags $ \ dflags ->
       -- But otherwise the CoPat is discarded, so it
       -- is the pattern inside that matters.  Sigh.
 
-pprPat :: (OutputableBndrId (GhcPass p)) => Pat (GhcPass p) -> SDoc
+pprPat :: (OutputableBndrId (GhcPass p))
+       => Pat (GhcPass p) -> SDoc
 pprPat (VarPat _ (L _ var))     = pprPatBndr var
 pprPat (WildPat _)              = char '_'
 pprPat (LazyPat _ pat)          = char '~' <> pprParendLPat appPrec pat
diff --git a/compiler/hsSyn/HsPat.hs-boot b/compiler/hsSyn/HsPat.hs-boot
index b7efb1c28c..68e11556f1 100644
--- a/compiler/hsSyn/HsPat.hs-boot
+++ b/compiler/hsSyn/HsPat.hs-boot
@@ -16,4 +16,5 @@ type role Pat nominal
 data Pat (i :: *)
 type LPat i = Located (Pat i)
 
-instance (p ~ GhcPass pass, OutputableBndrId p) => Outputable (Pat p)
+instance (p ~ GhcPass pass, OutputableBndrId p)
+      => Outputable (Pat p)
diff --git a/compiler/hsSyn/HsTypes.hs b/compiler/hsSyn/HsTypes.hs
index 11d301d816..6718d94b09 100644
--- a/compiler/hsSyn/HsTypes.hs
+++ b/compiler/hsSyn/HsTypes.hs
@@ -86,6 +86,7 @@ import TysPrim( funTyConName )
 import Type
 import HsDoc
 import BasicTypes
+import Binary
 import SrcLoc
 import Outputable
 import FastString
@@ -278,6 +279,7 @@ data HsQTvsRn
 type instance XHsQTvs       GhcPs = NoExt
 type instance XHsQTvs       GhcRn = HsQTvsRn
 type instance XHsQTvs       GhcTc = HsQTvsRn
+type instance XHsQTvs       GhcSe = NoExt
 
 type instance XXLHsQTyVars  (GhcPass _) = NoExt
 
@@ -317,6 +319,7 @@ data HsIBRn
 type instance XHsIB              GhcPs _ = NoExt
 type instance XHsIB              GhcRn _ = HsIBRn
 type instance XHsIB              GhcTc _ = HsIBRn
+type instance XHsIB              GhcSe _ = NoExt
 
 type instance XXHsImplicitBndrs  (GhcPass _) _ = NoExt
 
@@ -338,6 +341,7 @@ data HsWildCardBndrs pass thing
 type instance XHsWC              GhcPs b = NoExt
 type instance XHsWC              GhcRn b = [Name]
 type instance XHsWC              GhcTc b = [Name]
+type instance XHsWC              GhcSe b = NoExt
 
 type instance XXHsWildCardBndrs  (GhcPass _) b = NoExt
 
@@ -416,6 +420,10 @@ newtype HsIPName = HsIPName FastString
 hsIPNameFS :: HsIPName -> FastString
 hsIPNameFS (HsIPName n) = n
 
+instance Binary HsIPName where
+  put_ bh (HsIPName s) = put_ bh s
+  get bh = HsIPName <$> get bh
+
 instance Outputable HsIPName where
     ppr (HsIPName n) = char '?' <> ftext n -- Ordinary implicit parameters
 
@@ -673,6 +681,7 @@ type instance XKindSig         (GhcPass _) = NoExt
 type instance XSpliceTy        GhcPs = NoExt
 type instance XSpliceTy        GhcRn = NoExt
 type instance XSpliceTy        GhcTc = Kind
+type instance XSpliceTy        GhcSe = NoExt
 
 type instance XDocTy           (GhcPass _) = NoExt
 type instance XBangTy          (GhcPass _) = NoExt
@@ -681,16 +690,19 @@ type instance XRecTy           (GhcPass _) = NoExt
 type instance XExplicitListTy  GhcPs = NoExt
 type instance XExplicitListTy  GhcRn = NoExt
 type instance XExplicitListTy  GhcTc = Kind
+type instance XExplicitListTy  GhcSe = NoExt
 
 type instance XExplicitTupleTy GhcPs = NoExt
 type instance XExplicitTupleTy GhcRn = NoExt
 type instance XExplicitTupleTy GhcTc = [Kind]
+type instance XExplicitTupleTy GhcSe = NoExt
 
 type instance XTyLit           (GhcPass _) = NoExt
 
 type instance XWildCardTy      GhcPs = NoExt
 type instance XWildCardTy      GhcRn = HsWildCardInfo
 type instance XWildCardTy      GhcTc = HsWildCardInfo
+type instance XWildCardTy      GhcSe = NoExt
 
 type instance XXType         (GhcPass _) = NewHsTypeX
 
@@ -1223,6 +1235,7 @@ deriving instance (p ~ GhcPass pass, Ord (XFieldOcc p)) => Ord (FieldOcc p)
 type instance XFieldOcc GhcPs = NoExt
 type instance XFieldOcc GhcRn = Name
 type instance XFieldOcc GhcTc = Id
+type instance XFieldOcc GhcSe = NoExt
 
 type instance XXFieldOcc (GhcPass _) = NoExt
 
@@ -1253,10 +1266,12 @@ data AmbiguousFieldOcc pass
 type instance XUnambiguous GhcPs = NoExt
 type instance XUnambiguous GhcRn = Name
 type instance XUnambiguous GhcTc = Id
+type instance XUnambiguous GhcSe = NoExt
 
 type instance XAmbiguous GhcPs = NoExt
 type instance XAmbiguous GhcRn = NoExt
 type instance XAmbiguous GhcTc = Id
+type instance XAmbiguous GhcSe = NoExt
 
 type instance XXAmbiguousFieldOcc (GhcPass _) = NoExt
 
@@ -1299,7 +1314,8 @@ ambiguousFieldOcc (XFieldOcc _) = panic "ambiguousFieldOcc"
 ************************************************************************
 -}
 
-instance (p ~ GhcPass pass, OutputableBndrId p) => Outputable (HsType p) where
+instance (p ~ GhcPass pass, OutputableBndrId p)
+      => Outputable (HsType p) where
     ppr ty = pprHsType ty
 
 instance Outputable HsTyLit where
@@ -1357,7 +1373,8 @@ pprHsForAllTvs qtvs
   | null qtvs = whenPprDebug (forAllLit <+> dot)
   | otherwise = forAllLit <+> interppSP qtvs <> dot
 
-pprHsContext :: (OutputableBndrId (GhcPass p)) => HsContext (GhcPass p) -> SDoc
+pprHsContext :: (OutputableBndrId (GhcPass p))
+             => HsContext (GhcPass p) -> SDoc
 pprHsContext = maybe empty (<+> darrow) . pprHsContextMaybe
 
 pprHsContextNoArrow :: (OutputableBndrId (GhcPass p))
@@ -1416,13 +1433,16 @@ seems like the Right Thing anyway.)
 
 -- Printing works more-or-less as for Types
 
-pprHsType :: (OutputableBndrId (GhcPass p)) => HsType (GhcPass p) -> SDoc
+pprHsType :: (OutputableBndrId (GhcPass p))
+          => HsType (GhcPass p) -> SDoc
 pprHsType ty = ppr_mono_ty ty
 
-ppr_mono_lty :: (OutputableBndrId (GhcPass p)) => LHsType (GhcPass p) -> SDoc
+ppr_mono_lty :: (OutputableBndrId (GhcPass p))
+             => LHsType (GhcPass p) -> SDoc
 ppr_mono_lty ty = ppr_mono_ty (unLoc ty)
 
-ppr_mono_ty :: (OutputableBndrId (GhcPass p)) => HsType (GhcPass p) -> SDoc
+ppr_mono_ty :: (OutputableBndrId (GhcPass p))
+            => HsType (GhcPass p) -> SDoc
 ppr_mono_ty (HsForAllTy { hst_bndrs = tvs, hst_body = ty })
   = sep [pprHsForAllTvs tvs, ppr_mono_lty ty]
 
@@ -1493,7 +1513,8 @@ ppr_fun_ty ty1 ty2
     sep [p1, text "->" <+> p2]
 
 --------------------------
-ppr_app_ty :: (OutputableBndrId (GhcPass p)) => HsAppType (GhcPass p) -> SDoc
+ppr_app_ty :: (OutputableBndrId (GhcPass p))
+           => HsAppType (GhcPass p) -> SDoc
 ppr_app_ty (HsAppInfix _ (L _ n)) = pprInfixOcc n
 ppr_app_ty (HsAppPrefix _ (L _ (HsTyVar _ NotPromoted (L _ n))))
   = pprPrefixOcc n
diff --git a/compiler/hsSyn/PlaceHolder.hs b/compiler/hsSyn/PlaceHolder.hs
index 244243a82f..e05dfc3a33 100644
--- a/compiler/hsSyn/PlaceHolder.hs
+++ b/compiler/hsSyn/PlaceHolder.hs
@@ -9,6 +9,7 @@ module PlaceHolder where
 import Name
 import NameSet
 import RdrName
+import SeName
 import Var
 
 
@@ -68,3 +69,4 @@ type family NameOrRdrName id where
   NameOrRdrName Id      = Name
   NameOrRdrName Name    = Name
   NameOrRdrName RdrName = RdrName
+  NameOrRdrName SeName  = SeName
diff --git a/compiler/hsSyn/SeName.hs b/compiler/hsSyn/SeName.hs
new file mode 100644
index 0000000000..cccf8fb5ae
--- /dev/null
+++ b/compiler/hsSyn/SeName.hs
@@ -0,0 +1,10 @@
+module SeName (SeName(..), mkSeName) where
+
+import RdrName
+
+-- TODO: make this smarter, so as to check whether
+-- the name is local or not.
+newtype SeName = SeName RdrName
+
+mkSeName :: RdrName -> SeName
+mkSeName = SeName
diff --git a/compiler/iface/IfaceType.hs b/compiler/iface/IfaceType.hs
index 2524593663..f3b379a7eb 100644
--- a/compiler/iface/IfaceType.hs
+++ b/compiler/iface/IfaceType.hs
@@ -7,7 +7,7 @@ This module defines interface types and binders
 -}
 
 {-# LANGUAGE CPP, FlexibleInstances, BangPatterns #-}
-{-# LANGUAGE MultiWayIf #-}
+{-# LANGUAGE DeriveDataTypeable, MultiWayIf #-}
     -- FlexibleInstances for Binary (DefMethSpec IfaceType)
 
 module IfaceType (
@@ -69,6 +69,7 @@ import FastString
 import FastStringEnv
 import Util
 
+import Data.Data (Data)
 import Data.Maybe( isJust )
 import Data.List (foldl')
 import qualified Data.Semigroup as Semi
@@ -132,6 +133,7 @@ data IfaceType     -- A kind of universal type, used for types and kinds
        IsPromoted                 -- A bit like IfaceTyCon
        IfaceTcArgs                -- arity = length args
           -- For promoted data cons, the kind args are omitted
+  deriving Data
 
 type IfacePredType = IfaceType
 type IfaceContext = [IfacePredType]
@@ -139,7 +141,7 @@ type IfaceContext = [IfacePredType]
 data IfaceTyLit
   = IfaceNumTyLit Integer
   | IfaceStrTyLit FastString
-  deriving (Eq)
+  deriving (Data, Eq)
 
 type IfaceTyConBinder = TyVarBndr IfaceTvBndr TyConBndrVis
 type IfaceForAllBndr  = TyVarBndr IfaceTvBndr ArgFlag
@@ -154,6 +156,7 @@ data IfaceTcArgs
   | ITC_Vis   IfaceType IfaceTcArgs   -- "Vis" means show when pretty-printing
   | ITC_Invis IfaceKind IfaceTcArgs   -- "Invis" means don't show when pretty-printing
                                       --         except with -fprint-explicit-kinds
+  deriving Data
 
 instance Semi.Semigroup IfaceTcArgs where
   ITC_Nil <> xs           = xs
@@ -170,11 +173,11 @@ instance Monoid IfaceTcArgs where
 -- properly.
 data IfaceTyCon = IfaceTyCon { ifaceTyConName :: IfExtName
                              , ifaceTyConInfo :: IfaceTyConInfo }
-    deriving (Eq)
+    deriving (Data, Eq)
 
 -- | Is a TyCon a promoted data constructor or just a normal type constructor?
 data IsPromoted = IsNotPromoted | IsPromoted
-    deriving (Eq)
+    deriving (Data, Eq)
 
 -- | The various types of TyCons which have special, built-in syntax.
 data IfaceTyConSort = IfaceNormalTyCon          -- ^ a regular tycon
@@ -194,7 +197,7 @@ data IfaceTyConSort = IfaceNormalTyCon          -- ^ a regular tycon
                       -- that is actually being applied to two types
                       -- of the same kind.  This affects pretty-printing
                       -- only: see Note [Equality predicates in IfaceType]
-                    deriving (Eq)
+                    deriving (Data, Eq)
 
 {- Note [Free tyvars in IfaceType]
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -278,7 +281,7 @@ data IfaceTyConInfo   -- Used to guide pretty-printing
                       -- and to disambiguate D from 'D (they share a name)
   = IfaceTyConInfo { ifaceTyConIsPromoted :: IsPromoted
                    , ifaceTyConSort       :: IfaceTyConSort }
-    deriving (Eq)
+    deriving (Data, Eq)
 
 data IfaceCoercion
   = IfaceReflCo       Role IfaceType
@@ -303,12 +306,14 @@ data IfaceCoercion
   | IfaceSubCo        IfaceCoercion
   | IfaceFreeCoVar    CoVar    -- See Note [Free tyvars in IfaceType]
   | IfaceHoleCo       CoVar    -- ^ See Note [Holes in IfaceCoercion]
+  deriving Data
 
 data IfaceUnivCoProv
   = IfaceUnsafeCoerceProv
   | IfacePhantomProv IfaceCoercion
   | IfaceProofIrrelProv IfaceCoercion
   | IfacePluginProv String
+  deriving Data
 
 {- Note [Holes in IfaceCoercion]
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -1612,6 +1617,7 @@ instance Binary IfaceUnivCoProv where
            _ -> panic ("get IfaceUnivCoProv " ++ show tag)
 
 
+{-
 instance Binary (DefMethSpec IfaceType) where
     put_ bh VanillaDM     = putByte bh 0
     put_ bh (GenericDM t) = putByte bh 1 >> put_ bh t
@@ -1620,3 +1626,4 @@ instance Binary (DefMethSpec IfaceType) where
             case h of
               0 -> return VanillaDM
               _ -> do { t <- get bh; return (GenericDM t) }
+-}
diff --git a/compiler/main/DynFlags.hs b/compiler/main/DynFlags.hs
index 306a15a15b..0ccafa3480 100644
--- a/compiler/main/DynFlags.hs
+++ b/compiler/main/DynFlags.hs
@@ -904,6 +904,8 @@ data DynFlags = DynFlags {
   hiDir                 :: Maybe String,
   stubDir               :: Maybe String,
   dumpDir               :: Maybe String,
+  saveSplicesDir        :: Maybe String,
+  loadSplicesDir        :: Maybe String,
 
   objectSuf             :: String,
   hcSuf                 :: String,
@@ -1785,6 +1787,8 @@ defaultDynFlags mySettings (myLlvmTargets, myLlvmPasses) =
         hiDir                   = Nothing,
         stubDir                 = Nothing,
         dumpDir                 = Nothing,
+        saveSplicesDir          = Nothing,
+        loadSplicesDir          = Nothing,
 
         objectSuf               = phaseInputExt StopLn,
         hcSuf                   = phaseInputExt HCc,
@@ -2350,6 +2354,7 @@ getVerbFlags dflags
   | otherwise             = []
 
 setObjectDir, setHiDir, setStubDir, setDumpDir, setOutputDir,
+         setSaveSplicesDir, setLoadSplicesDir,
          setDynObjectSuf, setDynHiSuf,
          setDylibInstallName,
          setObjectSuf, setHiSuf, setHcSuf, parseDynLibLoaderMode,
@@ -2368,6 +2373,8 @@ setStubDir    f d = d { stubDir    = Just f
   -- \#included from the .hc file when compiling via C (i.e. unregisterised
   -- builds).
 setDumpDir    f d = d { dumpDir    = Just f}
+setSaveSplicesDir f d = d { saveSplicesDir = Just f}
+setLoadSplicesDir f d = d { loadSplicesDir = Just f}
 setOutputDir  f = setObjectDir f . setHiDir f . setStubDir f . setDumpDir f
 setDylibInstallName  f d = d { dylibInstallName = Just f}
 
@@ -2925,6 +2932,8 @@ dynamic_flags_deps = [
   , make_ord_flag defGhcFlag "tmpdir"            (hasArg setTmpDir)
   , make_ord_flag defGhcFlag "stubdir"           (hasArg setStubDir)
   , make_ord_flag defGhcFlag "dumpdir"           (hasArg setDumpDir)
+  , make_ord_flag defGhcFlag "save-splices"      (hasArg setSaveSplicesDir)
+  , make_ord_flag defGhcFlag "load-splices"      (hasArg setLoadSplicesDir)
   , make_ord_flag defGhcFlag "outputdir"         (hasArg setOutputDir)
   , make_ord_flag defGhcFlag "ddump-file-prefix"
         (hasArg (setDumpPrefixForce . Just))
diff --git a/compiler/main/HscStats.hs b/compiler/main/HscStats.hs
index ce59ca1877..96a01e7eb0 100644
--- a/compiler/main/HscStats.hs
+++ b/compiler/main/HscStats.hs
@@ -4,8 +4,7 @@
 -- (c) The GRASP/AQUA Project, Glasgow University, 1993-1998
 --
 
-{-# LANGUAGE FlexibleContexts #-}
-
+{-# LANGUAGE FlexibleContexts, GADTs #-}
 module HscStats ( ppSourceStats ) where
 
 import GhcPrelude
diff --git a/compiler/prelude/PrimOp.hs-boot b/compiler/prelude/PrimOp.hs-boot
index f10ef44972..6d759bb961 100644
--- a/compiler/prelude/PrimOp.hs-boot
+++ b/compiler/prelude/PrimOp.hs-boot
@@ -1,5 +1,7 @@
 module PrimOp where
 
-import GhcPrelude ()
+import GhcPrelude (Int)
 
 data PrimOp
+primOpTag :: PrimOp -> Int
+allThePrimOps :: [PrimOp]
diff --git a/compiler/typecheck/TcAnnotations.hs b/compiler/typecheck/TcAnnotations.hs
index 60872f749e..159c52a7e4 100644
--- a/compiler/typecheck/TcAnnotations.hs
+++ b/compiler/typecheck/TcAnnotations.hs
@@ -7,6 +7,7 @@
 
 {-# LANGUAGE CPP #-}
 {-# LANGUAGE FlexibleContexts #-}
+{-# LANGUAGE GADTs #-}
 
 module TcAnnotations ( tcAnnotations, annCtxt ) where
 
diff --git a/compiler/typecheck/TcEnv.hs b/compiler/typecheck/TcEnv.hs
index 0d875d7380..c87eaee68c 100644
--- a/compiler/typecheck/TcEnv.hs
+++ b/compiler/typecheck/TcEnv.hs
@@ -1,6 +1,6 @@
 -- (c) The University of Glasgow 2006
 {-# LANGUAGE CPP, FlexibleInstances #-}
-{-# LANGUAGE FlexibleContexts #-}
+{-# LANGUAGE FlexibleContexts, GADTs #-}
 {-# OPTIONS_GHC -fno-warn-orphans #-}  -- instance MonadThings is necessarily an
                                        -- orphan
 {-# LANGUAGE UndecidableInstances #-} -- Note [Pass sensitive types]
diff --git a/compiler/typecheck/TcHsSyn.hs b/compiler/typecheck/TcHsSyn.hs
index 8cabd0ca09..68c292f29b 100644
--- a/compiler/typecheck/TcHsSyn.hs
+++ b/compiler/typecheck/TcHsSyn.hs
@@ -111,7 +111,7 @@ hsPatType (NPlusKPat ty _ _ _ _ _)      = ty
 hsPatType (CoPat _ _ _ ty)              = ty
 hsPatType p                             = pprPanic "hsPatType" (ppr p)
 
-hsLitType :: HsLit (GhcPass p) -> TcType
+hsLitType :: LitType (GhcPass p) ~ Type => HsLit (GhcPass p) -> TcType
 hsLitType (HsChar _ _)       = charTy
 hsLitType (HsCharPrim _ _)   = charPrimTy
 hsLitType (HsString _ _)     = stringTy
diff --git a/compiler/typecheck/TcRnDriver.hs b/compiler/typecheck/TcRnDriver.hs
index 7730f7efd6..934dfb0fda 100644
--- a/compiler/typecheck/TcRnDriver.hs
+++ b/compiler/typecheck/TcRnDriver.hs
@@ -46,7 +46,7 @@ module TcRnDriver (
 
 import GhcPrelude
 
-import {-# SOURCE #-} TcSplice ( finishTH )
+import {-# SOURCE #-} TcSplice ( finishTH, writeHsSpliceData )
 import RnSplice ( rnTopSpliceDecls, traceSplice, SpliceInfo(..) )
 import IfaceEnv( externaliseName )
 import TcHsType
@@ -112,6 +112,7 @@ import Avail
 import TyCon
 import SrcLoc
 import HscTypes
+import HsExprBin
 import ListSetOps
 import Outputable
 import ConLike
@@ -135,6 +136,7 @@ import qualified Data.Set as S
 
 import Control.DeepSeq
 import Control.Monad
+import System.Directory
 
 #include "HsVersions.h"
 
@@ -416,6 +418,17 @@ tcRnSrcDecls explicit_mod_hdr decls
         -- Finalizers must run after constraints are simplified, or some types
         -- might not be complete when using reify (see #12777).
       ; (tcg_env, tcl_env) <- setGblEnv tcg_env run_th_modfinalizers
+
+      ; dynflags <- getDynFlags
+      ; whenSet (saveSplicesDir dynflags)
+          (\splicesDir -> do
+              moduleSplicesPath <- getModuleSplicesPath splicesDir <$> getModule
+              hs_splice_data <- readTcRef (tcg_hs_splice_data tcg_env)
+              liftIO $ createDirectoryIfMissing True splicesDir
+              writeHsSpliceData moduleSplicesPath hs_splice_data
+          )
+          (pure ())
+
       ; setEnvs (tcg_env, tcl_env) $ do {
 
       ; finishTH
diff --git a/compiler/typecheck/TcRnMonad.hs b/compiler/typecheck/TcRnMonad.hs
index a68d0f504a..1647f8d191 100644
--- a/compiler/typecheck/TcRnMonad.hs
+++ b/compiler/typecheck/TcRnMonad.hs
@@ -145,6 +145,7 @@ import IOEnv            -- Re-export all
 import TcEvidence
 
 import HsSyn hiding (LIE)
+import HsExprBin
 import HscTypes
 import Module
 import RdrName
@@ -182,7 +183,7 @@ import Control.Monad
 import Data.Set ( Set )
 import qualified Data.Set as Set
 
-import {-# SOURCE #-} TcSplice ( runRemoteModFinalizers )
+import {-# SOURCE #-} TcSplice ( runRemoteModFinalizers, readHsSpliceData )
 import {-# SOURCE #-} TcEnv    ( tcInitTidyEnv )
 
 import qualified Data.Map as Map
@@ -228,9 +229,16 @@ initTc hsc_env hsc_src keep_rn_syntax mod loc do_this
         th_coreplugins_var <- newIORef [] ;
         th_state_var         <- newIORef Map.empty ;
         th_remote_state_var  <- newIORef Nothing ;
+        dflags <- pure (hsc_dflags hsc_env) ;
+        hs_splice_data <- newIORef =<< whenSet (loadSplicesDir dflags)
+          (\splicesDir -> do
+              if moduleUnitId mod == interactiveUnitId
+                then return emptyHsSpliceData
+                else do let moduleSplicesPath = getModuleSplicesPath splicesDir mod
+                        readHsSpliceData hsc_env moduleSplicesPath
+          )
+          (pure emptyHsSpliceData) ;
         let {
-             dflags = hsc_dflags hsc_env ;
-
              maybe_rn_syntax :: forall a. a -> Maybe a ;
              maybe_rn_syntax empty_val
                 | dopt Opt_D_dump_rn_ast dflags = Just empty_val
@@ -304,7 +312,8 @@ initTc hsc_env hsc_src keep_rn_syntax mod loc do_this
                 tcg_top_loc        = loc,
                 tcg_static_wc      = static_wc_var,
                 tcg_complete_matches = [],
-                tcg_cc_st          = cc_st_var
+                tcg_cc_st          = cc_st_var,
+                tcg_hs_splice_data = hs_splice_data
              } ;
         } ;
 
diff --git a/compiler/typecheck/TcRnTypes.hs b/compiler/typecheck/TcRnTypes.hs
index 73b15a5252..50744e06e1 100644
--- a/compiler/typecheck/TcRnTypes.hs
+++ b/compiler/typecheck/TcRnTypes.hs
@@ -159,6 +159,7 @@ import TyCoRep  ( CoercionHole(..), coHoleCoVar )
 import Coercion ( Coercion, mkHoleCo )
 import ConLike  ( ConLike(..) )
 import DataCon  ( DataCon, dataConUserType, dataConOrigArgTys )
+import {-# SOURCE #-} HsExprBin
 import PatSyn   ( PatSyn, pprPatSynType )
 import Id       ( idType, idName )
 import FieldLabel ( FieldLabel )
@@ -688,7 +689,20 @@ data TcGblEnv
         tcg_complete_matches :: [CompleteMatch],
 
         -- ^ Tracking indices for cost centre annotations
-        tcg_cc_st   :: TcRef CostCentreState
+        tcg_cc_st   :: TcRef CostCentreState,
+
+        -- ^ Splice evaluation results
+        --
+        -- When @-save-splices@ is passed, we will
+        -- record splice results in this field and write
+        -- them all to an .hs-splice file when we are done
+        -- processing the module.
+        --
+        -- When @-load-splices@ is passed, we will read
+        -- the .hs-splice file before we start processing a
+        -- module (when it exists) and store all its contents
+        -- in this field.
+        tcg_hs_splice_data :: TcRef HsSpliceData
     }
 
 -- NB: topModIdentity, not topModSemantic!
diff --git a/compiler/typecheck/TcSplice.hs b/compiler/typecheck/TcSplice.hs
index 5bef07f369..dda8d449a5 100644
--- a/compiler/typecheck/TcSplice.hs
+++ b/compiler/typecheck/TcSplice.hs
@@ -26,6 +26,7 @@ module TcSplice(
      runMetaE, runMetaP, runMetaT, runMetaD, runQuasi,
      tcTopSpliceExpr, lookupThName_maybe,
      defaultRunMeta, runMeta', runRemoteModFinalizers,
+     readHsSpliceData, writeHsSpliceData,
      finishTH
       ) where
 
@@ -34,6 +35,7 @@ module TcSplice(
 import GhcPrelude
 
 import HsSyn
+import HsExprBin
 import Annotations
 import Finder
 import Name
@@ -111,6 +113,9 @@ import Maybes( MaybeErr(..) )
 import DynFlags
 import Panic
 import Lexeme
+import BinIface ( getWithUserData, putWithUserData )
+import IfaceEnv ( NameCacheUpdater(..) )
+import qualified Binary as Bin
 import qualified EnumSet
 import Plugins
 
@@ -132,6 +137,7 @@ import Data.Typeable ( typeOf, Typeable, TypeRep, typeRep )
 import Data.Data (Data)
 import Data.Proxy    ( Proxy (..) )
 import GHC.Exts         ( unsafeCoerce# )
+import System.Directory ( doesFileExist )
 
 {-
 ************************************************************************
@@ -672,12 +678,26 @@ runQResult show_th f runQ expr_span hval
 
 
 -----------------
+
 runMeta :: (MetaHook TcM -> LHsExpr GhcTc -> TcM hs_syn)
+        -> (LHsExpr GhcTc -> TcM hs_syn)
+           -- ^ function to load the result of the given expression from
+           --   an .hs-splice file's data
+        -> (LHsExpr GhcTc -> hs_syn -> TcM ())
+           -- ^ function to "save" the result (hs_syn) of evaluating the given
+           --   LHsExpr
         -> LHsExpr GhcTc
         -> TcM hs_syn
-runMeta unwrap e
-  = do { h <- getHooked runMetaHook defaultRunMeta
-       ; unwrap h e }
+runMeta unwrap loadSpliceFun saveSpliceFun e
+  = do { dflags <- getDynFlags
+       ; whenSet (loadSplicesDir dflags)
+           (\_ -> loadSpliceFun e)
+           (do { h <- getHooked runMetaHook defaultRunMeta
+               ; res <- unwrap h e
+               ; whenSet (saveSplicesDir dflags)
+                   (\_ -> saveSpliceFun e res)
+                   (return ())
+               ; return res }) }
 
 defaultRunMeta :: MetaHook TcM
 defaultRunMeta (MetaE r)
@@ -694,29 +714,101 @@ defaultRunMeta (MetaAW r)
     -- the toAnnotationWrapper function that we slap around the user's code
 
 ----------------
+
+readHsSpliceData :: HscEnv -> FilePath -> IO HsSpliceData
+readHsSpliceData hsc_env hsSpliceFile = do
+  let ncu = NCU (updNameCache hsc_env)
+  exists <- doesFileExist hsSpliceFile
+  if exists
+    then do bh <- Bin.readBinMem hsSpliceFile
+            getWithUserData ncu bh
+    else pure emptyHsSpliceData
+
+writeHsSpliceData :: FilePath -> HsSpliceData -> TcM ()
+writeHsSpliceData hsSpliceFile hsSpliceData =
+  when (nonEmptyHsSpliceData hsSpliceData) $ do
+    dflags <- getDynFlags
+    liftIO $ do
+      bh <- Bin.openBinMem (100 * 1024)
+      --  ^^^ FIXME: how should we compute an approximation of size?
+      putWithUserData (debugTraceMsg dflags 3) bh hsSpliceData
+      Bin.writeBinMem bh hsSpliceFile
+
+-- | Update the splice data from the TcGblEnv using the given
+--   function. Used when -save-splices is passed, to record
+--   the splice results as we evaluate them and dump them
+--   to an .hs-splice file.
+modifyHsSpliceData :: (HsSpliceData -> HsSpliceData) -> TcM ()
+modifyHsSpliceData f = do
+  spliceDataRef <- tcg_hs_splice_data <$> getGblEnv
+  updTcRef spliceDataRef f
+
+-- | Record the result (second argument) of evaluating the expression splice
+--   represented by the first argument.
+addSpliceExprResult :: LHsExpr GhcTc -> LHsExpr GhcPs -> TcM ()
+addSpliceExprResult (L l _) resultE = do
+  serialExpr <- exprPS2SE resultE
+  modifyHsSpliceData (recordSpliceResult l (SRExpr serialExpr))
+
+-- | Record the result (second argument) of evaluating the declaration splice
+--   represented by the first argument.
+addSpliceDeclsResult :: LHsExpr GhcTc -> [LHsDecl GhcPs] -> TcM ()
+addSpliceDeclsResult (L l _) resultDs = do
+  serialDecls <- traverse declPS2SE resultDs
+  modifyHsSpliceData (recordSpliceResult l (SRDecls serialDecls))
+
+-- | Look up the result of evaluating the splice represented by the first
+--   argument in an .hs-splice file, using the given function to extract
+--   the result in question (when found).
+getSpliceResult :: LHsExpr GhcTc -> (SpliceResult -> TcM a) -> TcM a
+getSpliceResult (L l _) f = do
+  gblEnv <- getGblEnv
+  hs_splice_data <- readTcRef (tcg_hs_splice_data gblEnv)
+  case lookupSpliceResult l hs_splice_data of
+    Nothing -> panic ("Could not find splice result for source span " ++ show l)
+    Just r  -> f r
+
+-- | Look up the result of evaluating an expression splice.
+getSpliceExprResult :: LHsExpr GhcTc -> TcM (LHsExpr GhcPs)
+getSpliceExprResult spliceE = getSpliceResult spliceE $ \res -> case res of
+    SRExpr e  -> exprSE2PS e
+    SRDecls _ -> panic ("Expected an expression splice but found a declaration one")
+
+-- | Look up the result of evaluating a declaration splice.
+getSpliceDeclsResult :: LHsExpr GhcTc -> TcM [LHsDecl GhcPs]
+getSpliceDeclsResult spliceE = getSpliceResult spliceE $ \res -> case res of
+    SRExpr _   -> panic ("Expected a declaration splice result but found an expression one")
+    SRDecls ds -> traverse declSE2PS ds
+
 runMetaAW :: LHsExpr GhcTc         -- Of type AnnotationWrapper
           -> TcM Serialized
 runMetaAW = runMeta metaRequestAW
+  (panic "runMetaAW doesn't support splice caching (read)")
+  (panic "runMetaAW doesn't support splice caching (write)")
 
 runMetaE :: LHsExpr GhcTc          -- Of type (Q Exp)
          -> TcM (LHsExpr GhcPs)
-runMetaE = runMeta metaRequestE
+runMetaE = runMeta metaRequestE getSpliceExprResult addSpliceExprResult
 
 runMetaP :: LHsExpr GhcTc          -- Of type (Q Pat)
          -> TcM (LPat GhcPs)
 runMetaP = runMeta metaRequestP
+  (panic "runMetaP doesn't support splice caching (read)")
+  (panic "runMetaP doesn't support splice caching (write)")
 
 runMetaT :: LHsExpr GhcTc          -- Of type (Q Type)
          -> TcM (LHsType GhcPs)
 runMetaT = runMeta metaRequestT
+  (panic "runMetaT doesn't support splice caching (read)")
+  (panic "runMetaT doesn't support splice caching (write)")
 
 runMetaD :: LHsExpr GhcTc          -- Of type Q [Dec]
          -> TcM [LHsDecl GhcPs]
-runMetaD = runMeta metaRequestD
+runMetaD = runMeta metaRequestD getSpliceDeclsResult addSpliceDeclsResult
 
 ---------------
 runMeta' :: Bool                 -- Whether code should be printed in the exception message
-         -> (hs_syn -> SDoc)                                    -- how to print the code
+         -> (hs_syn -> SDoc)     -- how to print the code
          -> (SrcSpan -> ForeignHValue -> TcM (Either MsgDoc hs_syn))        -- How to run x
          -> LHsExpr GhcTc        -- Of type x; typically x = Q TH.Exp, or
                                  --    something like that
@@ -727,7 +819,7 @@ runMeta' show_code ppr_hs run_and_convert expr
                             -- we catch all kinds of splices and annotations.
 
         -- Check that we've had no errors of any sort so far.
-        -- For example, if we found an error in an earlier defn f, but
+        -- For example, if we fouénd an error in an earlier defn f, but
         -- recovered giving it type f :: forall a.a, it'd be very dodgy
         -- to carry ont.  Mind you, the staging restrictions mean we won't
         -- actually run f, but it still seems wrong. And, more concretely,
diff --git a/compiler/typecheck/TcSplice.hs-boot b/compiler/typecheck/TcSplice.hs-boot
index be2c67d887..003948c1fb 100644
--- a/compiler/typecheck/TcSplice.hs-boot
+++ b/compiler/typecheck/TcSplice.hs-boot
@@ -9,6 +9,8 @@ import HsExpr   ( PendingRnSplice )
 import TcRnTypes( TcM , SpliceType )
 import TcType   ( ExpRhoType )
 import Annotations ( Annotation, CoreAnnTarget )
+import HscTypes    ( HscEnv )
+import HsExprBin   ( HsSpliceData )
 import HsExtension ( GhcTcId, GhcRn, GhcPs )
 
 import HsSyn      ( HsSplice, HsBracket, HsExpr, LHsExpr, LHsType, LPat,
@@ -42,3 +44,6 @@ lookupThName_maybe :: TH.Name -> TcM (Maybe Name)
 runQuasi :: TH.Q a -> TcM a
 runRemoteModFinalizers :: ThModFinalizers -> TcM ()
 finishTH :: TcM ()
+
+readHsSpliceData :: HscEnv -> FilePath -> IO HsSpliceData
+writeHsSpliceData :: FilePath -> HsSpliceData -> TcM ()
\ No newline at end of file
diff --git a/compiler/typecheck/TcType.hs-boot b/compiler/typecheck/TcType.hs-boot
index 2bc14735f1..1b014c2d2a 100644
--- a/compiler/typecheck/TcType.hs-boot
+++ b/compiler/typecheck/TcType.hs-boot
@@ -4,5 +4,6 @@ import Outputable( SDoc )
 data MetaDetails
 
 data TcTyVarDetails
+
 pprTcTyVarDetails :: TcTyVarDetails -> SDoc
 vanillaSkolemTv :: TcTyVarDetails
diff --git a/compiler/types/CoAxiom.hs b/compiler/types/CoAxiom.hs
index 63c21627c8..c8334ddd42 100644
--- a/compiler/types/CoAxiom.hs
+++ b/compiler/types/CoAxiom.hs
@@ -39,9 +39,9 @@ import Name
 import Unique
 import Var
 import Util
-import Binary
 import Pair
 import BasicTypes
+import Binary
 import Data.Typeable ( Typeable )
 import SrcLoc
 import qualified Data.Data as Data
@@ -440,15 +440,16 @@ instance Outputable Role where
   ppr = ftext . fsFromRole
 
 instance Binary Role where
-  put_ bh Nominal          = putByte bh 1
-  put_ bh Representational = putByte bh 2
-  put_ bh Phantom          = putByte bh 3
-
-  get bh = do tag <- getByte bh
-              case tag of 1 -> return Nominal
-                          2 -> return Representational
-                          3 -> return Phantom
-                          _ -> panic ("get Role " ++ show tag)
+  put_ bh r = putByte bh $ case r of
+    Nominal          -> 0
+    Representational -> 1
+    Phantom          -> 2
+  get bh = do
+    tag <- getByte bh
+    pure $ case tag of
+      0 -> Nominal
+      1 -> Representational
+      _ -> Phantom
 
 {-
 ************************************************************************
@@ -501,7 +502,6 @@ instance Ord CoAxiomRule where
 instance Outputable CoAxiomRule where
   ppr = ppr . coaxrName
 
-
 -- Type checking of built-in families
 data BuiltInSynFamily = BuiltInSynFamily
   { sfMatchFam      :: [Type] -> Maybe (CoAxiomRule, [Type], Type)
diff --git a/compiler/types/TyCoRep.hs-boot b/compiler/types/TyCoRep.hs-boot
index 3753e70b84..29a0cea373 100644
--- a/compiler/types/TyCoRep.hs-boot
+++ b/compiler/types/TyCoRep.hs-boot
@@ -1,7 +1,6 @@
 module TyCoRep where
 
 import GhcPrelude
-
 import Outputable ( SDoc )
 import Data.Data  ( Data )
 
diff --git a/compiler/types/TyCon.hs b/compiler/types/TyCon.hs
index 5717aef9b8..730f44a7ed 100644
--- a/compiler/types/TyCon.hs
+++ b/compiler/types/TyCon.hs
@@ -583,7 +583,6 @@ instance Binary TyConBndrVis where
                   0 -> return AnonTCB
                   _ -> do { vis <- get bh; return (NamedTCB vis) } }
 
-
 {- *********************************************************************
 *                                                                      *
                The TyCon type
diff --git a/compiler/utils/Binary.hs b/compiler/utils/Binary.hs
index 447317ca47..594d3586c9 100644
--- a/compiler/utils/Binary.hs
+++ b/compiler/utils/Binary.hs
@@ -63,12 +63,16 @@ module Binary
 import GhcPrelude
 
 import {-# SOURCE #-} Name (Name)
+import Bag
 import FastString
 import Panic
+import Unique
 import UniqFM
+import UniqSet
 import FastMutInt
 import Fingerprint
 import BasicTypes
+import {-# SOURCE #-} PrimOp
 import SrcLoc
 
 import Foreign
@@ -76,14 +80,16 @@ import Data.Array
 import Data.ByteString (ByteString)
 import qualified Data.ByteString.Internal as BS
 import qualified Data.ByteString.Unsafe   as BS
+import qualified Data.IntMap              as IM
 import Data.IORef
 import Data.Char                ( ord, chr )
+import Data.List                ( find )
 import Data.Time
 import Type.Reflection
 import Type.Reflection.Unsafe
 import Data.Kind (Type)
 import GHC.Exts (TYPE, RuntimeRep(..), VecCount(..), VecElem(..))
-import Control.Monad            ( when )
+import Control.Monad            ( when, replicateM )
 import System.IO as IO
 import System.IO.Unsafe         ( unsafeInterleaveIO )
 import System.IO.Error          ( mkIOError, eofErrorType )
@@ -380,8 +386,8 @@ instance Binary () where
     get  _    = return ()
 
 instance Binary Bool where
-    put_ bh b = putByte bh (fromIntegral (fromEnum b))
-    get  bh   = do x <- getWord8 bh; return $! (toEnum (fromIntegral x))
+    put_ bh b = putByte bh (if b then 1 else 0)
+    get  bh   = do x <- getByte bh; return $! if x == 0 then False else True
 
 instance Binary Char where
     put_  bh c = put_ bh (fromIntegral (ord c) :: Word32)
@@ -1173,3 +1179,130 @@ instance Binary SourceText where
         s <- get bh
         return (SourceText s)
       _ -> panic $ "Binary SourceText:" ++ show h
+
+instance Binary IntegralLit where
+  put_ bh (IL a b c) = put_ bh a >> put_ bh b >> put_ bh c
+  get bh = IL <$> get bh <*> get bh <*> get bh
+
+instance Binary FractionalLit where
+  put_ bh (FL a b c) = put_ bh a >> put_ bh b >> put_ bh c
+  get bh = FL <$> get bh <*> get bh <*> get bh
+
+instance Binary Boxity where
+  put_ bh b = case b of
+    Boxed   -> putByte bh 0
+    Unboxed -> putByte bh 1
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure Boxed
+      _ -> pure Unboxed
+
+-- FIXME: optimise?
+instance (Ix i, Binary i, Binary a) => Binary (Array i a) where
+  put_ bh arr = case bounds arr of
+    (a, b) -> put_ bh a >> put_ bh b >> put_ bh (elems arr)
+  get bh = do
+    bounds <- (,) <$> get bh <*> get bh
+    xs <- replicateM (rangeSize bounds) (get bh)
+    return (listArray bounds xs)
+
+instance Binary Unique where
+  put_ bh u = put_ bh (getKey u)
+  get bh = mkUniqueGrimily <$> get bh
+
+instance Binary ty => Binary (DefMethSpec ty) where
+  put_ bh s
+    = case s of
+        VanillaDM   -> putByte bh 0
+        GenericDM t -> putByte bh 1 >> put_ bh t
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure VanillaDM
+      _ -> GenericDM <$> get bh
+
+instance Binary a => Binary (IM.IntMap a) where
+  put_ bh m = put_ bh (IM.toAscList m)
+  get bh = IM.fromAscList <$> get bh
+
+instance Binary PrimOp where
+  put_ bh primop = put_ bh (primOpTag primop)
+  -- FIXME: inefficient.
+  get bh = do
+    tag <- getTag
+    case find (\p -> primOpTag p == tag) allThePrimOps of
+      Nothing -> error "Binary PrimOp.get: unknown primop tag"
+      Just p  -> pure p
+
+    where getTag :: IO Int
+          getTag = get bh
+
+instance Binary OccInfo where
+  put_ bh i
+    = case i of
+        ManyOccs a          -> putByte bh 0 >> put_ bh a
+        IAmDead             -> putByte bh 1
+        OneOcc a b c d      -> putByte bh 2 >> put_ bh a >> put_ bh b
+                                            >> put_ bh c >> put_ bh d
+        IAmALoopBreaker a b -> putByte bh 3 >> put_ bh a >> put_ bh b
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> ManyOccs <$> get bh
+      1 -> pure IAmDead
+      2 -> OneOcc <$> get bh <*> get bh <*> get bh <*> get bh
+      _ -> IAmALoopBreaker <$> get bh <*> get bh
+
+instance Binary TailCallInfo where
+  put_ bh i
+    = case i of
+        AlwaysTailCalled a -> putByte bh 0 >> put_ bh a
+        NoTailCallInfo     -> putByte bh 1
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> AlwaysTailCalled <$> get bh
+      _ -> pure NoTailCallInfo
+
+instance Binary OneShotInfo where
+  put_ bh i
+    = case i of
+        NoOneShotInfo -> putByte bh 0
+        OneShotLam    -> putByte bh 1
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure NoOneShotInfo
+      _ -> pure OneShotLam
+
+instance Binary LexicalFixity where
+  put_ bh f = case f of
+    Prefix -> putByte bh 0
+    Infix  -> putByte bh 1
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure Prefix
+      _ -> pure Infix
+
+instance Binary ele => Binary (UniqFM ele) where
+  put_ bh ufm = put_ bh (ufmToIntMap ufm)
+  get bh = intMapToUFM <$> get bh
+
+instance Binary a => Binary (UniqSet a) where
+  put_ bh s = put_ bh (getUniqSet s)
+  get bh = unsafeUFMToUniqSet <$> get bh
+
+instance Binary a => Binary (Bag a) where
+  put_ bh b = put_ bh (bagToList b)
+  get bh = listToBag <$> get bh
+
+instance Binary Origin where
+  put_ bh o = putByte bh $ case o of
+    FromSource -> 0
+    Generated  -> 1
+  get bh = getByte bh >>= \n -> case n of
+    0 -> pure FromSource
+    1 -> pure Generated
+    _ -> panic "Binary Origin.get: unknown tag"
diff --git a/compiler/utils/UniqDFM.hs b/compiler/utils/UniqDFM.hs
index 715600ddb8..90389da0d1 100644
--- a/compiler/utils/UniqDFM.hs
+++ b/compiler/utils/UniqDFM.hs
@@ -62,6 +62,7 @@ module UniqDFM (
 import GhcPrelude
 
 import Unique           ( Uniquable(..), Unique, getKey )
+import Binary
 import Outputable
 
 import qualified Data.IntMap as M
@@ -128,6 +129,10 @@ instance Eq val => Eq (TaggedVal val) where
 instance Functor TaggedVal where
   fmap f (TaggedVal val i) = TaggedVal (f val) i
 
+instance Binary val => Binary (TaggedVal val) where
+  put_ bh (TaggedVal a b) = put_ bh a >> put_ bh b
+  get bh = TaggedVal <$> get bh <*> get bh
+
 -- | Type of unique deterministic finite maps
 data UniqDFM ele =
   UDFM
@@ -139,6 +144,10 @@ data UniqDFM ele =
                                 -- time. See Note [Overflow on plusUDFM]
   deriving (Data, Functor)
 
+instance Binary ele => Binary (UniqDFM ele) where
+  put_ bh (UDFM a b) = put_ bh a >> put_ bh b
+  get bh = UDFM <$> get bh <*> get bh
+
 emptyUDFM :: UniqDFM elt
 emptyUDFM = UDFM M.empty 0
 
diff --git a/compiler/utils/UniqFM.hs b/compiler/utils/UniqFM.hs
index a80880f4e5..33bd1810ae 100644
--- a/compiler/utils/UniqFM.hs
+++ b/compiler/utils/UniqFM.hs
@@ -66,7 +66,7 @@ module UniqFM (
         lookupWithDefaultUFM, lookupWithDefaultUFM_Directly,
         nonDetEltsUFM, eltsUFM, nonDetKeysUFM,
         ufmToSet_Directly,
-        nonDetUFMToList, ufmToIntMap,
+        nonDetUFMToList, ufmToIntMap, intMapToUFM,
         pprUniqFM, pprUFM, pprUFMWithKeys, pluralUFM
     ) where
 
@@ -338,6 +338,9 @@ nonDetUFMToList (UFM m) = map (\(k, v) -> (getUnique k, v)) $ M.toList m
 ufmToIntMap :: UniqFM elt -> M.IntMap elt
 ufmToIntMap (UFM m) = m
 
+intMapToUFM :: M.IntMap elt -> UniqFM elt
+intMapToUFM = UFM
+
 -- Determines whether two 'UniqFm's contain the same keys.
 equalKeysUFM :: UniqFM a -> UniqFM b -> Bool
 equalKeysUFM (UFM m1) (UFM m2) = liftEq (\_ _ -> True) m1 m2
diff --git a/run_test.sh b/run_test.sh
new file mode 100755
index 0000000000..e80be57745
--- /dev/null
+++ b/run_test.sh
@@ -0,0 +1,17 @@
+#!/usr/bin/env sh
+
+set -e
+
+time make -j4 V=0
+
+rm -rf my-splices
+
+# we install aeson and microlens-th
+cabal install -w $(pwd)/inplace/bin/ghc-stage2 --package-db=$(pwd)/inplace/lib/package.conf.d aeson microlens-th --allow-newer --disable-library-profiling
+
+# we evaluate the splices and save the results
+inplace/bin/ghc-stage2 -fforce-recomp -save-splices my-splices/ -fno-code -ddump-splices simple_json_th.hs
+
+# we reuse those results to avoid the need to run any TH, even compiling
+# the program with stage 1!
+inplace/bin/ghc-stage1 -fforce-recomp -load-splices my-splices/ -o simple_json_th -ddump-splices simple_json_th.hs
diff --git a/simple_json_th.hs b/simple_json_th.hs
new file mode 100644
index 0000000000..54b794fa96
--- /dev/null
+++ b/simple_json_th.hs
@@ -0,0 +1,35 @@
+{- To install aeson before building this program:
+$ cabal install -w $(pwd)/inplace/bin/ghc-stage2 \
+              \ --package-db=$(pwd)/inplace/lib/package.conf.d aeson microlens microlens-th \
+              \ --disable-library-profiling --allow-newer
+
+Then:
+$ inplace/bin/ghc-stage2 -fforce-recomp -save-splices my-splices/ -fno-code simple_json_th.hs
+$ inplace/bin/ghc-stage2 -fforce-recomp -load-splices my-splices/ -o simple_json_th simple_json_th.hs
+-}
+{-# LANGUAGE TemplateHaskell #-}
+import Data.Aeson
+import Data.Aeson.TH
+import Lens.Micro.TH
+
+data Point = P
+  { _x, _y, _z :: Int }
+  deriving Show
+
+pos :: Point
+pos = P 12 1 34
+
+$(deriveJSON defaultOptions ''Point)
+makeLenses ''Point
+
+data Segment = Segment
+  { _src :: Point
+  , _tgt :: Point
+  } deriving Show
+
+makeClassy ''Segment
+
+main :: IO ()
+main = do
+  print pos
+  print (encode pos)
